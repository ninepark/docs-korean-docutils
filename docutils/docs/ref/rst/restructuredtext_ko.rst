.. -*- coding: utf-8 -*-

=======================================
 reStructuredText 마크업(Markup) 설명서
=======================================

:저자: David Goodger
:메일주소: docutils-develop@lists.sourceforge.net
:개정: $Revision$
:날짜: $Date$
:저작권: 이 문서는 공공 도메인에 속해있다.

.. Note::

   이 문서는 튜토리얼이나 입문서가 아닌 상세한 기술 설명서다.
   만약 reStructuredText를 처음 접한다면, `A ReStructuredText Primer`_ dhk
   `Quick reStructuredText`_ 사용자 레퍼런스(reference)를 먼저 읽기 바란다.

.. _A ReStructuredText Primer: ../../user/rst/quickstart_ko.html
.. _Quick reStructuredText: ../../user/rst/quickref_ko.html


reStructuredText_ 는 단순하고 직관적인 구조를 이용해서 문서의 체계를 표현하는
일반 텍스트(plaintext)이다. 이 구조(construct)는 처리 전이나 후에 상관없이
읽기 쉽다. 이 문서는 이 자체로 reStructuredText의 예다. (예를 들어, 텍스트
문서를 읽고 있다면 처리되기 전이며, HTML을 읽고 있다면 처리된 후다.)
reStructuredText 파서(parser)는 Docutils_ 의 구성요소이다.

단순하고, 암시적인(implicit) 마크업(markup)은 섹션 제목이나 bullet list,
강조 같은 특수 구조(special construct)를 표현하기 위해 사용된다.
사용되는 마크업은 가능한 최소화되고 거슬리지 않게 되어있다.
적게 사용되는 구조나 기본 reStructuredText 신택스(syntax)의 확장 기능은
더 복잡하고 명시적(explicit)이다.

reStructuredText 는 인라인(inline) 프로그램 문서 부분(파이썬 독스트링(docstring))
처럼 매우 짧거나 이 문서처럼 매우 긴 길이의 문서에도 적용할 수 있다.

첫 번째 섹션은 reStructuredText 마크업 구문의 예시와 함께 간단한 개관으로
이루어져있다. 완전한 설명은 `Syntax Details`_ 섹션에서 제공된다.

마크업이 처리되지 않은 `Literal blocks`_ 은 일반 텍스트 상태의 마크업을
보여주기 위해 사용되었다.


.. contents::


-----------------------
 Quick Syntax Overview
-----------------------

reStructuredText 문서는 본문이나 block-level의 요소로 구성되어 있으며
섹션으로 나눌 수 있다. Sections_ 은 타이틀 스타일(언더라인(underlines)
선택적인(optional) 오버라인(overlines))을 통해서 표시된다. 섹션은 본문 요소
(elements)와 하위 섹션을 포함하고 있다. 몇몇 본문 요소는 (단락과 기타 본문
요소를 포함하는) 리스트 항목 같은 추가적인 요소를 포함하고 있다. 단락과 같은
다른 본문 요소는 텍스트와 `inline markup`_ 요소를 포함하고 있다.

`body elements`_ 예시:

- Paragraphs_ (과 `inline markup`_)::

      단락은 텍스트와 인라인 마크업을 포함하고 있다:
      *강조*, **강한 강조**, `해석된(interpreted) 텍스트`, ``인라인 리터럴
      (literal)``, 자립형 하이퍼링크(standalone hyperlinks);
      (http://www.python.org), 외부 하이퍼링크(external hyperlinks);
      (Python_), 내부 상호 참조(internal cross-references); (example_),
      각주 참조(footnote references); ([1]_), 인용 참조(citation references);
      ([CIT2002]_), 대체 참조(substitution references); (|example|),
      _`인라인 내부 타겟(inline internal targets)`.

      단락은 빈 줄로 나눠져있고 왼쪽 정렬되어있다.

- 리스트 타입 다섯 가지:

  1. `Bullet lists`_::

         - 이것은 bullet lists다.

         - 글머리 기호(Bullet)는 "*", "+", "-"를 사용할 수 있다.

  2. `Enumerated lists`_::

         1. 이것은 enumerated lists다.

         2. 숫자는 아라비아 숫자, 글자 로마 숫자를 사용할 수 있다.

  3. `Definition lists`_::

         개념
             Definition lists 용어와 용어를 정의하는 부분을 결합시킨다.

         사용 방식
             용어는 한 줄의 구문이고, 정의하는 부분은 하나 이상의 단락이나
             본문 요소로 구성되어 있으며 용어보다 들여쓰기 되어야 한다.

  4. `Field lists`_::

         :개념: Field lists는 필드 이름(field names)와 데이터 베이스 기록
                같은 필드 내용을 결합시킨다. 확장구문의 일부로 사용될 수 있다.

         :방법: The field는 콜론, 필드 이름, 콜론으로 표시한다.

                필드의 본문은 하나 이상의 본문 요소를 포함하고 있으며
                필드 이름을 표시한 것보다 들여쓰기 되어 있어야 한다.

  5. `Option lists`_, 커맨드라인 옵션(command-line options)을 위한 리스트::

         -a            커맨드라인 옵션 "a"
         -b file       인수(arguments)를 가지는 옵션과
                       그에 대한 긴 설명
         --long        긴(long) 옵션
         --input=file  긴 옵션 또한 인수를 가질 수
                       있다.
         /V            DOS/VMS 스타일 옵션도 가능하다

     옵션과 설명 사이에 최소한 두 칸 이상 공백이 있어야 한다.

- `Literal blocks`_::

      Literal blocks은 들여쓰기 되거나 라인 접두사로 인용된(line-prefix-quoted)
      블럭이며 선행된 단락의 끝에 더블 콜론(double-colon)("::")을 써서 나타낼
      수 있다. (이곳 처럼 -->)::

          if 리터럴_블럭에서는 :
              텍스트 = '그대로 표현된다'
              띄어쓰기와_개행 = '보존된다'
              마크업_처리 = 이루어지지 않는다

- `Block quotes`_::

      블럭 인용(Block quotes)은 본문 요소를 들여쓰면 된다:

          This theory, that is mine, is mine.

          -- Anne Elk (Miss)

- `Doctest blocks`_::

      >>> print '파이썬 사용 예제; ">>>"로 시작된다'
      파이썬 사용 예제; ">>>"로 시작된다
      >>> print '(대화형(interactive) Python 세션에서 복사, 붙여넣을 수 있다)'
      (대화형(interactive) Python 세션에서 복사, 붙여넣을 수 있다)

- Two syntaxes for tables_:

  1. `Grid tables`_; 완전하지만 복잡하고 장황하다(verbose)::

         +-------------------+----------+--------+
         | 헤더 행, 1 열      | 헤더 2   | 헤더 3 |
         +===================+==========+========+
         | 본문 1 행, 1 열    | 2 열     | 3 열   |
         +-------------------+----------+--------+
         | 본문 2 행          | 셀 병합 가능       |
         +-------------------+-------------------+

  2. `Simple tables`_;  쉽고 간결하지만 제한적이다::

         ====================  ==========  ==========
         헤더 행, 1 열          헤더 2      헤더 3
         ====================  ==========  ==========
         본문 1 행, 1 열        2 열        3 열
         본문 2 행              셀의 열 병합 가능
         ====================  ======================

- `Explicit markup blocks`_ 명시적 블럭 마커(explicit block marker,
  마침표 두 개, 스페이스 한 번)로 시작한다:

  - Footnotes_::

        .. [1] 각주는 적어도 스페이스 3번 이상으로 일관되게 들여쓰여진
           본문 요소를 포함한다.

  - Citations_::

        .. [CIT2002] 라벨이 문자인 것을 제외하면 각주와 같다.

  - `Hyperlink targets`_::

        .. _Python: http://www.python.org

        .. _example:

        위의 "_example" 타겟이 이 단락을 가리킨다.

  - Directives_::

        .. image:: mylogo.png

  - `Substitution definitions`_::

        .. |기호| image:: symbol.png

  - Comments_::

        .. 코멘트는 두 점과 스페이스 한 번으로 시작된다. 각주/인용 구문,
           하이퍼링크 타겟, 명령어(directives), 대체 정의(substitution definitions)
           를 제외하고는 어떤 것을 써도 상관 없다.


----------------
 Syntax Details
----------------

아래의 설명은 신택스 구조에 대응하는 "doctree elements" (문서 트리 요소의 이름
; XML DTD 일반 식별자(generic indentifier))를 나열하고 있다.  요소의 체계에
관한 세부사항은, `The Docutils Document Tree`_ 와 `Docutils Generic DTD`_
XML 문서 타입 정의를 참고하라.


Whitespace
==========

들여쓰기(indentation_)는 스페이스를 사용할 것을 추천하지만 탭도 사용할 수 있다.
탭은 띄어쓰기로 변환될 것이다. 탭 위치(tab stop)는 8번째 열마다 있다.

다른 공백 문자 (폼 피드(form feeds) [chr(12)]와 수직 탭(vertical tabs)
[chr(11)])은 처리 전에 단일 스페이스로 변환된다.


Blank Lines
-----------

공백 행은 단락이나 다른 요소를 구분하기 위해 사용된다.
여러 줄의 공백 행은 모든 공백 문자가 보존되는 리터럴 블럭 안을 제외하고는
하나의 공백 행과 같다. 공백 행은 마크업이 요소 구분을 명확하게 할 때 들여쓰기와
함께 생략될 수 있다. 문서의 첫 번째 줄은 공백행이 앞에 있는 것으로 처리되며
문서의 마지막 줄은 공백 행이 다음에 오는 것으로 처리된다.


Indentation
-----------

들여쓰기는 블럭 인용이나 definition list 항목 내의 정의, 지역적으로 내포되어있는
내용(local nested content)을 나타낼 때에만 중요하게 사용된다:

- list 항목 내용 (내포된 리스트를 포함해 리스트 항목의 여러줄짜리 내용과 본문 요소),
- 리터럴 블럭의 내용,
- 명시적 마크업 블럭의 내용.

현재 레벨에 비해 적게 들여쓰여진 (들여쓰기가 되지 않은 텍스트나 내어쓰기 된) 텍스트는
현재 레벨의 들여쓰기를 끝내버린다.

모든 줄의 들여쓰기가 중요하기 때문에, 들여쓰기 레벨은 일관성이 있어야 한다.
예를 들어, 들여쓰기는 `block quotes`_ 를 위한 유일한 마크업 표시기이다::

    이 단락은 레벨이 가장 높은 단락이다.

        이 단락은 첫 번째 레벨의 블럭 인용이다.

        첫 번째 레벨 블럭 인용의 단락 2이다.

블럭 인용 내에서 여러 레벨의 들여쓰기를 사용하면 구조를 복합적으로 만들 수 있다::

    이 단락은 레벨이 가장 높은 단락이다.

        이 단락은 첫 번째 레벨 블럭 인용에 속해 있다.

            이 단락은 두 번째 레벨 블럭 인용에 속해 있다.

    또 다른 가장 높은 레벨의 단락.

            이 단락은 두 번째 레벨 블럭 인용에 속해 있다.

        이 단락은 첫 번째 레벨 블럭 인용에 속해 있다. 위에 있는 두 번쨰 레벨
        블럭 인용은 이 첫 번째 레벨 인용 블럭의 안에 있다.

단락이나 다른 구조가 한 줄 이상의 텍스트로 구성되어 있을 때, 각 행은 반드시
왼쪽으로 정렬 되어 있어야 한다::

    이 부분은 한 단락이다. 이 단락의 각 행은
    왼쪽으로 정렬되어 있다.

        이 단락은 문제가 있다. 각 행이
    왼쪽으로 정렬되어 있지 않다. 이 경우
      해석이 잘못됨과 동시에 파서(parser)에 의해
        경고나 에러 메세지가
      발생할 것이다


몇몇 구조는 마커로 시작하고, 구조의 본문은 마커에 비해 반드시 들여쓰기
되어 있어야 한다. 간단한 마커를 사용하는 구조의 경우
(`bullet lists`_, `enumerated lists`_, footnotes_, citations_,
`hyperlink targets`_, directives_, comments_), 본문의 들여쓰기 레벨은
마커와 같은 줄에서 시작하는 텍스트의 첫 번째 줄 위치에 의해 결정된다.
예를 들어, bullet list 본문은 글머리 기호(bullet)의 왼쪽 가장자리보다 최소한
두 열 이상은 들여쓰기 되어야 한다::

    - 이것은 bullet list 항목 단락의 첫 번째 줄이다.
      모든 줄은 반드시 첫 줄에 따라서 정렬되어야 한다.  [1]_

          이 들여쓰여진 단락은 인용 블럭으로 해석된다.

    이 단락은 충분히 들여쓰여지지 않았기 때문에
    리스트 항목에 속하지 않는다.

    .. [1] 이건 각주이며 두 번째 줄은 각주 레이블의 시작 부분에
       정렬되어 있다. 들여쓰기는 ".." 마커가 결정한다.

임의의 텍스트를 포함하는 복잡한 마커를 사용하는 구조 (`field lists`_ 와 `option
lists`_) 는 마커의 *다음* 에 오는 첫 번째 줄이 본문의 왼쪽 가장자리를 결정한다.
예를 들어, field list는 필드 이름이 굉장히 긴 마커를 쓸 수도 있다::

    :Hello: 이 필드는 짧은 필드 이름을 가지고 있다, 그렇기 때문에 같은 줄에서 부터
            본문을 정렬시켜도 문제가 없다.

    :Number-of-African-swallows-required-to-carry-a-coconut:
        이 필드 본문은 마커와 같은 줄에서부터 정렬시키기가 매우 힘들다.
        이 경우 마커와 같은 줄에서 본문을 시작하지 않는 것이 더 좋다.


Escaping Mechanism
==================

7-bit ASCII 일반 텍스트 문서에서 일반적으로 사용 가능한 문자는 제한되어
있다. 마크업에 어떤 문자를 쓰더라도, 그 문자들은 텍스트에서 원래 여러 의미를 가지고
있을 것이다. 그러므로 마크업 문자는 가끔씩 **마크업으로 의도되지 않은 것처럼**
텍스트에서 나타나야 한다. 마크업 시스템은 마크업을 위해 사용되는 문자의 기본 의미를
무시하기 위한 이스케이핑 메커니즘(Escaping Mechanism)을 필요로 한다.
reStructuredText는 다른 도메인에서도 일반적으로 사용하는 백슬래쉬를 사용한다.

백슬래쉬는 (non-URI 컨텍스트(context) 내에서의 공백 문자를 제외한) 바로 뒤에 쓰여진
문자를 이스케이프(escape) 시킨다. 이스케이프된 문자는 문자 그 자체를 나타내고 마크업
역할을 하지 않는다. 백슬래쉬는 출력물에서 제외된다. 문자 그 자체로의 백슬래쉬는 백슬래쉬를
두 번 연달아 써서 나타낼 수 있다. (첫 번째 백슬래쉬가 두 번째 백슬래쉬를
이스케이프 하게 만들어서 두 번째 백슬래쉬가 이스케이핑 역할을 못 하도록 막는다.)

Non-URI 컨텍스트에서 백슬래쉬로 이스케이프된 공백 문자는 문서에서 제거된다.
이것은 문자 레벨의 `inline markup`_ 을 가능하게 한다 .

URI에서는, 백슬래쉬로 이스케이프된 공백은 문자는 단일 스페이스로 나타난다.

백슬래쉬가 특수한 의미를 갖지 않는 컨텍스트는 두 가지가 있다:
바로 리터럴 블럭과 인라인 리터럴이다. 이 경우에는 백슬래쉬를 연달아 두 번 쓰지
않아도 백슬래쉬 그대로 표현된다.

reStructuredText 설명서와 파서는 입력 텍스트의 추출과 표현에 대한
이슈들(실제로 어떤 형식의 텍스트가 어떻게 파서에 도달하는지)을 다루지 않는다는
점을 참고하기 바란다. 백슬래쉬나 다른 문자들은 특정 컨텍스트 안에서 문자를
이스케이프시킬 목적으로로 사용될 수 있으므로 적절하게 다루어져야 한다.
예를 들어 파이썬은 문자열(string)에서 특정 문자를
이스케이프 시키기 위해 백슬래쉬를 사용하지만 다른 언어는 그렇지 않다.
파이썬 독스트링(doctsring)에서 백슬래쉬가 나타날 때 가장 쉬운 해결첵은
raw 독스트링을 사용하는 것이다::

    r"""이것이 raw doctring이다. 백슬래쉬 (\)는 처리되지 않는다)."""


Reference Names
===============

단순 참조 이름(simple reference name)은 영글자 숫자와 (인접하지 않게) 분리된
내부 하이픈, 언더스코어, 마침표, 콜론, 기호로 구성된 하나의 단어다; 공백이나
다른 문자는 사용할 수 없다. 각주 라벨 (Footnotes_ & `Footnote References`_),
인용 라벨 (Citations_ & `Citation References`_), `interpreted text`_ role,
과 몇몇 `hyperlink references`_ 는 단순 참조 이름 신택스를 사용한다.

구두점을 사용하거나 이름이 구문(두 개 이상의 띄어쓰기로 연결된 단어)인 참조 이름은
"구문 참조(phrase-references)"라고 한다.
구문 참조는 백 쿼트(backqouote)에 싸여진 구문으로 표현되고
백 쿼트 안의 구문이 참조 이름이 된다::

    `my favorite programming language`_ 에 대해서 배우고 싶은가?

    .. _my favorite programming language: http://www.python.org

단순 참조도 백쿼트를 사용할 수 있다.

참조 이름은 대소문자를 구분하지 않고 공백 중립적(whitespace-neutral)이다.
내부적으로 참조 이름을 변환할 때:

- 공백은 정규화 된다. 하나 이상의 스페이스, 수평, 수직 탭,
  개행(new line), 개행(carriage returns), 서식 이송(form feeds)은 하나의
  스페이스로 해석된다. 그리고,

- 문자도 표준화 된다. (모든 영어 문자는 소문자로 변환된다.)

예를 들어, 아래의 `hyperlink references`_ 는 모두 동일하다::

    - `A HYPERLINK`_
    - `a    hyperlink`_
    - `A
      Hyperlink`_

Hyperlinks_, footnotes_, citations_ 는 참조 이름에 대해서 같은 이름 공간(namespace)
을 공유한다. 인용 라벨 (단순 참조 이름)과 수동으로 번호가 매겨진 각주(숫자)는
다른 하이퍼링크 이름과 동일한 데이터베이스에 속하게 된다.
이 말은 각주 참조(``[1]_``)과 연결되는 각주("``.. [1]``")는
하이퍼 링크 참조(1_) 와도 연결될 수 있다는 의미이다.
물론, 각 종류의 참조(hyperlink, footnote, citation)는 다른 방식으로
해석되고 처리될 것이다. 따라서 참조 이름의 충돌을 피하기 위해서는 주의가 필요하다.


Document Structure
==================

Document
--------

독트리(Doctree) 요소: 문서.

파싱된 reStructuredText 문서의 최상위 레벨 요소는 "문서(document)" 요소다.
최초의 파싱이 끝나면, 문서 요소는 `body elements`_, transitions_,
sections_ 으로 구성된 문서 조각(fragment)을 포함하는 단순한 컨테이너이며, 문서 제목이나
다른 서지(bibliographic) 요소는 없다. 파서를 호출하는 코드는 하나 이상의 추가적인
post-parse transforms_ 을 실행시킬 수 있으며, 문서 조각을 제목과 기타 메타데이터 요소
(저자, 날짜 등; `Bibliographic Fields`_ 참고)를 가진 완전한 문서로 재배열 합니다.

.. _document title:

엄밀히 말하면, reStructuredText에서 문서 제목과 부제목을 명시적으로 표현할 수
있는 방법은 없다. [#]_ 대신, 하나의 최상위 레벨 섹션 타이틀(아래의 Sections_ 참고)
을 문서의 제목으로 처리할 수 있다.
마찬가지로 하나의 차 상위 레벨의 섹션 제목을 문서 제목의 바로 아래에 놓으면
문서의 부제목으로 처리할 수 있다. 그러면 나머지 섹션은 레벨이 1, 2단계씩 오르게 된다.
자세한 내용은 `DocTitle transform`_ 을 참고하라.

.. [#] `title`_ 설정을 변경하면 문서의 제목을 문서 본문의 일부가 되지 않도록
   조정할 수 있다.

.. _title: ../../user/config.html#title


Sections
--------

독트리 요소: 섹션, 제목.

섹션은 마크업을 통해 꾸며진 각 섹션의 제목을 통해 식별된다:
타이틀 텍스트 아래에 "언더라인" 표시를 하거나 언더라인에 맞춰서 "오버라인"까찌 표시.
오버라인/언더라인은 단일 구분 문자를 줄의 처음부터 적어도 제목 텍스트의
오른쪽 끝까지 반복해서 형성한 줄을 말한다. 언더라인/오버라인에 사용하는 문자는 글자와
숫자가 아니면서 출력 가능한 7-bit ASCII 문자면 된다 [#]_.
오버라인까지 사용할 경우 사용하는 문자와 줄의 길이가 언더라인과 같아야 된다.
언더라인만 사용된 꾸미기(adornment) 스타일은 같은 문자를 사용한 밑줄 윗줄 스타일과 구분된다.
비록 몇몇 출력 형식에 제한이 있기는 하지만만HTML은 6레벨 까지) 섹션 제목의 레벨은
제한이 없다.

.. [#] 아래는 섹션 타이틀 꾸미기에 사용될 수 있는 문자들이다::

       ! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~

   몇가지 문자들은 다른 문자에 비해 더 적합하다. 아래의 문자들이
   권장된다::

       = - ` : . ' " ~ ^ _ * + #

순서는 고정된 섹션 제목 꾸미기 스타일과 숫자를 강제로 지정하는 것이 아니라,
쓰여진 순서대로 자동적으로 정해진다. 첫 번째로 쓰여진 스타일이 가장 바깥쪽
(outermost) 타이틀이 되고, 두 번째 스타일이 부제목, 세 번째가 부부제목이 되는
식이다.

아레는 제목 스타일의 예시다::

    ===============
     Section Title
    ===============

    ---------------
     Section Title
    ---------------

    Section Title
    =============

    Section Title
    -------------

    Section Title
    `````````````

    Section Title
    '''''''''''''

    Section Title
    .............

    Section Title
    ~~~~~~~~~~~~~

    Section Title
    *************

    Section Title
    +++++++++++++

    Section Title
    ^^^^^^^^^^^^^

제목에 언더라인과 오버라인이 모두 있을 때, 제목 텍스트는 위쪽의 처음 두
예시와 같이 가운데 정렬할 수 있다. 이것은 단지 미적인 이유 때문일 뿐
중요한 것은 아니다. 언더라인만 쓰는 경우는 텍스트를 들여쓰면 *안* 된다.

제목 아래에 공백 행을 쓰는 것은 선택적인 부분이다. 동일하거나 더 높은
레벨 전까지의 텍스트 블럭은 한 섹션(또는 하위 섹션 등)에 포함된다.

모든 섹션 제목 스타일이 다 쓰일 필요는 없으며, 특정한 제목 스타일만 쓸 필요도
없다. 단, 문서는 섹션 제목 사용에 있어서 일관성을 유지해야 한다: 제목 스타일의
쳬계가 일단 정해지면, 모든 섹션은 반드시 그 체계를 따라야 한다.

섹션의 제목은 자동적으로 각 섹션을 가리키는 하이퍼 링크 타겟을 생성한다.
하이퍼 링크 타켓의 텍스트("참조 이름")는 섹션 제목이다. 자세한 설명은`Implicit
Hyperlink Targets`_ 를 참고하라.

섹션은 `body elements`_, transitions_, 내포된 섹션을 포함할 수 있다.


Transitions
-----------

독트리 요소: 전환.

    부제를 다는 것 대신에, 단락 사이에 빈 공간을 두거나 기호를 입력하는 것으로
    텍스트를 분리하고 주제가 저ㅗㄴ환됨을 표현할 수 있다.

    (The Chicago Manual of Style, 14th edition, section 1.80)

전환은 소설에서 자주 볼 수 있는데, 별표로 된 줄 같은 장식을 쓰거나 한 줄 이상으로
간격을 벌려놓은 것을 말한다. 전환은 다른 본문 요소를 분리시킨다.
전환은 섹션이나 문서를 시작하거나 끝낼 수 없으며, 두개의 전환 부분이
바로 붙어 있을 수도 없다.

전환 마커를 위한 신택스는 구분 문자를 4번 이상 수평적으로 반복시킨 것이다.
이 신택스는 제목 텍스트가 없는 섹션 타이틀 언더라인과 똑같다.
전환 마커 라인의 위, 아래에는 공백 행이 필요하다::

    Para.

    ----------

    Para.

섹션 제목 언더라인과 다르게, 전환 마커의 계층 구조는 존재하지 않으며
전환 마커의 차이는 아무 것도 발생시키지 않는다. 따라서 단일한
일관된 스타일을 사용할 것을 추천한다.

프로세싱 시스템은 원하는 방식으로 자유롭게 전환을 렌더링할 수 있습니다.
예를 들어, HTML 출력에서는 수평줄 (``<hr>``)이 선택될 것이다.


Body Elements
=============

Paragraphs
----------

독트리 요소: 단락.

단락은 다른 본문 요소를 표시하는 마크업이 없는 왼쪽으로 정렬된 텍스트 블럭으로
구성되어 있다. 공백 행은 단락을 다른 본문 요소나 단락과 구분지어 준다. 단락은
`inline markup`_ 을 포함할 수 있다.

신택스 다이어그램::

    +------------------------------+
    | 단락                         |
    |                              |
    +------------------------------+

    +------------------------------+
    | 단락                         |
    |                              |
    +------------------------------+


Bullet Lists
------------

독트리 요소: bullet_list, 리스트 항목.

"*", "+", "-", "•", "‣", "⁃"로 시작하고 공백 문자로 띄어진 텍스트 블럭은
bullet list 항목(순서가 없는 리스트 항목)이라고 한다. 리스트 항목의
본문은 반드시 글머리 기호(bullet)보다 들여쓰여진 상태로 왼쪽 정렬 되어
있어야 한다; 글머리 기호 바로 다음에 오는 첫 번째 텍스트가 들여쓰기를 결정한다.
예를 들면::

    - 이것은 첫 번째 bullet list 항목이다. 첫 번째 리스트 항목의 위에는
      공백 행이 있어야 한다; 이 단락의 아래처럼 리스트 항목 사이에 공백 행을
      쓰는 것은 선택적인 부분이다.

    - 이것은 리스트의 두 번째 항목의 첫 번째 단락이다.

      이 두 번째 단락은 두 번째 항목의 속해있다. 이 단락의 위에는 공백 행이
      삽입 되어야 한다. 이 단락의 왼쪽 가장자리는 위쪽에 있는 단락에 맞춰야 하며
      모두 글머리 기호보다 들여쓰여져야 한다.

      - 이것은 하위 리스트다. 글머리 기호의 왼쪽 가장자리는 위쪽 텍스트 블럭의
        가장자리를 따라야 한다. 하위 리스트는 또다른 새로운 리스트이기 때문에
        항목의 위 아래에 공백 행이 삽입되어야 한다.

    - 이것은 메인 리스트의 세 번째 항목이다.

    이 단락은 리스트에 속해있지 않다.

아래는 **잘못** 작성된 bullet list의 예시이다::

    - 첫 번째 줄은 이상이 없다.
    리스트 항목과 단락 사이에는 공백 행이 삽입되어야 한다.
    (경고)

    - 아래의 몇 줄들은 새로운 하위 리스트로 보이지만 실제로는 그렇지 않다:
      - 사이에 공백 행이 삽입되지 않았기 때문에 이것은 하위리스트가
        아니라 연결된 단락이다. 그리고 들여쓰기도 제대로 되어있지 않은 상태다.
      - 이러한 경우 변환 시에 경고가 발생될 수 있다.

신택스 다이어그램::

    +------+-----------------------+
    | "- " | 리스트 항목            |
    +------| (본문 요소)+           |
           +-----------------------+


Enumerated Lists
----------------

독트리 요소: enumerated_list, 리스트 항목.

Enumerated list(순서가 있는 리스트)는 bullet list와 비슷하지만
글머리 기호 대신에 숫자나 문자를 사용한다. 열거자(enumerator)는
열거 시퀀스(enumeration sequence) 멤버와 포맷팅(formatting), 바로 뒤의
공백문자로 구성되어 있다. 열거 시퀀스는 아래 다섯 종류를 사용할 수 있다:

- 아라비아 숫자: 1, 2, 3, ... (수에 제한이 없다).
- 알파벳 대문자: A, B, C, ..., Z.
- 알파벳 소문자: a, b, c, ..., z.
- 로마 숫자 대문자: I, II, III, IV, ..., MMMMCMXCIX (4999).
- 로마 숫자 소문자: i, ii, iii, iv, ..., mmmmcmxcix (4999).

그리고 자동 열거자인 "#"를 사용하면 자동적으로 리스트에 숫자를 매길
수 있다. 자동 enumerated list는 시퀀스를 설정하는 명시적 열거로 시작한다.
완전 자동 enumerated list는 아라비아 숫자를 사용하고 1로 시작한다.
(자동 enumerated list는 Docutils 0.3.8.에서 새로 등장했다)

포매팅 스타일은 아래 세 가지가 인식된다:

- 구두점이 뒤에 붙은 타입: "1.", "A.", "a.", "I.", "i.".
- 괄호에 싸인 타입: "(1)", "(A)", "(a)", "(I)", "(i)".
- 괄호가 오른쪽에만 붙은 타입: "1)", "A)", "a)", "I)", "i)".

enumerated list를 파싱 할 때, 아래의 경우에는 새로운 리스트가 시작된다:

- 열거자가 현재의 리스트와 다른 시퀀스 타입과 포매팅 스타일을 사용했을 경우
  ("1.", "(a)"를 쓰면 두 개의 리스트를 생성한다).

- 열거자의 순서가 맞지 않는 경우("1.", "3." 두 개의 리스트
  생성한다).

첫 번째 리스트 항목의 열거자로 는시퀀스의의 첫 번째 문자
("1", "A", "a", "I", or "i")를 사용하는 것을 추천한다. 다른 문자로 시작
해도 되지만 출력 포맷이 지원해주지 못할 수도 있다. 첫 번째 문자가 아닌
다른 문자로 리스트를 시작하면 level-1 [info] 시스템 메세지가 발생할 것이다.

로마 숫자를 사용하는 리스트는 반드시 "I"/"i"나, "II", "XV" 같이 여러 개로
이루어진 문자로 시작해야 한다. 다른 한 글자 짜리 로마 문자
("V", "X", "L", "C", "D", "M")로 시작하면 로마 숫자가 아니라 알파벳
글자로 해석될 것이다. 마찬가지로 알파벳을 사용하는 리스트는 로마 숫자로
인식될 수 있기 때문에 "I"/"i"로 시작하면 안 된다.

각 enumerated list 항목의 두 번째 줄은 리스트의 유효성을 확인하는데 사용된다.
이는 텍스트가 열거자와 동일한 문자로 시작했을 때 일반적인 단락을 잘못해서
리스트 항목으로 인식되는 것을 막기 위함이다. 예를 들면 아래의 텍스트는
일반적인 단락으로 파싱된다::

    A. Einstein was a really
    smart dude.

그러나, 단락이 한 문장일 경우 판단이 애매해진다.
아래의 텍스트는 enumerated list 항목으로 파싱된다::

    A. Einstein was a really smart dude.

단락이 열거자와 동일한 문자("A.", "1.", "(b)", "I)" 등)로 텍스트가
시작된다면 일반적인 단락으로 파싱되기 위해 이스케이프 되어야 한다::

    \A. Einstein was a really smart dude.

enumerated list 내에 enumerated list가 있는 예시::

    1. 항목 1 시작하는 텍스트.

       a) 항목 1a.
       b) 항목 1b.

    2. a) 항목 2a.
       b) 항목 2b.

신택스 다이어그램 예시::

    +-------+----------------------+
    | "1. " | 리스트 항목           |
    +-------| (본문 요소)+          |
            +----------------------+


Definition Lists
----------------

독트리 요소: definition_list, definition_list 항목, 용어,
구분자(classifier), 정의.

각각의 definition list 항목은 용어와 선택적인 구분자, 정의로
이루어져 있다. 용어는 한 줄의 구문이나 단어이다. 선택적인 구분자는 용어와
같은 줄에서 " : " (공백, 콜론, 공백) 다음에 위치한다. 정의는 용어보다 들여쓰기
된 블럭이며 여러 단락과 다른 본문 요소들을 포함할 수 있다.
정의 블럭과 용어 줄 사이에는 공백 행이 있어서는 안된다(이 부분으로 definition lists와
`block quotes`_ 를 구분한다). definition list의 첫 번째 항목의 위쪽과
마지막 항목의 아래쪽에는 공백 행이 삽입 되어야 하며 그 사이에는 선택적으로
삽입할 수 있다::

    용어 1
        정의 1.

    용어 2
        정의 2, 단락 1.

        정의 2, 단락 2.

    용어 3 : 구분자
        정의 3.

    용어 4 : 구분자 1 : 구분자 2
        정의 4.

인라인 마크업은 구분자 구분 기호 (" : ")가 인식되기 전에 파싱된다.
구분기호는 인라인 마크업의 외부에서 나타날 때에만 인식된다.

definition list는 다양한 방식으로 사용될 수 있다:

- 사전으로 사용할 수 있다. 용어를 단어로 쓰고, 구분자로 용어의
  품사(noun, verb, etc.)를 나타내고 아래에서 뜻을 정의하면 된다.

- 프로그램 변수를 설명할 때 사용할 수 있다. 용어는 변수 이름으로 놓고,
  구분자로 변수의 타입(string, integer, etc.)을 표시하고 프로그램에서
  변수가 어떻게 사용되는지 정의하면 된다. 이 definition lists를 사용하면
  파이썬 객체(object) 스키마(scheme)를 기술하고 실행하는 시스템인 Grouch_ 의
  구분자 신택스가 지원된다.

신택스 다이어그램::

    +----------------------------+
    | 용어 [ " : " 구분자       ]* |
    +--+-------------------------+--+
       | 정의                        |
       | (본문 요소)+                 |
       +----------------------------+


Field Lists
-----------

독트리 요소: field_list, 필드, 필드 이름, 필드 본문.

Field lists는 directives_ 를 위한 옵션 같은 신택스 확장 기능의 일부나 추가적인
처리를 위한 데이터 베이스 형태의 기록을 위해 사용됩니다. 또한 데이터 베이스
기록(라벨 & 데이터 쌍)과 유사한 2열 테이블형태의 구조에도 사용될 수 있다.
reStructuredText 응용 프로그램은 필드 이름을 인식하고 특정 내용의
필드나 필드 본문을 변환할 수 있다. 예시를 확인하려면, 아래의
`Bibliographic Fields`_ 또는, `reStructuredText Directives`_
내에 있는 "image_", "meta_" 명령어(directives)를 참고하라.

.. _field names:

Field lists는 RFC822_ headers을 모델로 *필드 이름* 을 *필드 내용* 으로
맵핑(mapping)한다. 필드 이름은 어떤 문자로 되어 있어도 상관 없지만
안에 콜론(":")을 사용해야 될 경우 백슬래쉬를 사용해 이스케이프 시켜야한다.
인라인 마크업은 필드 이름 안에서 파싱된다. 필드 이름은 추가적으로 처리되거나
변환될 때 대소문자를 구분하지 않는다. 앞, 뒤에 붙은 콜론과 필드 이름은
합쳐서 하나의 필드 마커를 형성한다. 필드 마커 뒤에는 공백문자와 필드 본문이
위치한다. 필드 본문은 필드 마커에 비해 들여쓰여져야 하며 여러 본문 요소를
포함할 수 있다. 필드 마커 뒤의 첫 번째 줄이 필드 본문의 들여쓰기를 결정한다::

    :날짜: 2001-08-16
    :버전: 1
    :저자: - Me
              - Myself
              - I
    :들여쓰기: 필드 마커가 꽤 길 수도 있기 때문에, 필드 본문의 두 번째와 이후의
       행들은 첫 번째 행과 정렬될 필요는 없지만 필드 이름 마커에 비해서는 들여쓰기
       되어야 한다. 그리고 그 행들은 서로 정렬되어있어야 한다.
    :모수 i: 정수

여러 단어로 이루어진 필드 이름 안의 개별적인 단어들의 해석은 응용 프로그램에 따라
다르다. 응용 프로그램은 필드 이름에 대한 신택스를 지정할 수 있다.
예를 들어 두 번째와 이후의 단어가 "인수(argument)"로 처리된다면 인용된 구절은
단일 인수로 다루어질 수 있고 "이름=값" 신택스에 대한 직접적인 지원이
추가될 수 있다.

Standard RFC822_ headers는 규정이 애매하기 때문에 이 구조를 위해 사용될
수 없다. 줄의 시작 부분에 있는 콜론 앞의 단어는 텍스트에서 공통적이다.
그러나 문서의 시작 부분에서 filed list가 일관되게 쓰여지는 경우처럼(PEP,
이메일 메세지 등) 잘 정의된 컨텍스트에서는 standard RFC822 headers도 사용될 수 있다.

단순화시킨 신택스 다이어그램::

    +--------------------+----------------------+
    | ":" 필드 이름 ":"    | 필드 본문              |
    +-------+------------+                      |
            | (본문 요소)+                        |
            +-----------------------------------+


Bibliographic Fields
````````````````````

독트리 요소: 문서 정보(docinfo), 저자, 기관, 연락처,
버전, 상태, 날짜, 저작권, 필드, 주제.

Field list가 문서 내에서 주석이 아닌 첫 번째 요소일 때(제목이 있으면
제목 다음에), 필드는 문서의 서지(bibliographic) 자료로 변형될 수 있다.
이 서지 자료는 책의 제목 페이지나 저작권 페이지 처럼 책의 전문(front matter)과
일치한다.

(아래에 있는) 지정된 특정한 필드 이름은 인식 된 다음 일치하는 독트리 요소로
변환되는데 대부분 "문서 정보" 요소의 하위 요소가 된다. 문서 구조에 맞춰서
재배열 될 수는 있지만 순서를 지정할 필요는 없다.
아래 쪽에서 달리 명시하지 않는 한, 문헌 요소의 각 필드 본문은 하나의 단락만
포함할 수 있다. 필드 본문은 `RCS keywords`_ 에 대해 확인되고 정리될 수 있다.
인식되지 않은 필드는 문서 정보 요소 안의 일반 필드로 남겨진다.

지정된 bibliographic field 이름과 대응하는 독트리 요소는 다음과 같다:

- 필드 이름 "Author": author element.
- "Authors": authors.
- "Organization": organization.
- "Contact": contact.
- "Address": address.
- "Version": version.
- "Status": status.
- "Date": date.
- "Copyright": copyright.
- "Dedication": topic.
- "Abstract": topic.

"Authors" 필드는 ";"나 ","로 구분된 저자 리스트로 구성된 한 단락을 포함할수도
있고 각 요소가 저자 한 명당 한 단락으로 구성된 bullet list를 포함할 수도 있다.
";"가 먼저 확인되기 때문에 "Doe, Jane; Doe, John"로 쓸 수 있다.
스웨덴어 같은 특정한 언어의 경우 "Author"와 "Authors" 사이에 단복수 구분이 없기
때문에 "Authors" 필드만이 제공된다. 그리고 한 사람의 이름은 "Author"로
해석된다. 만약 한 사람의 이름이 콤마를 포함한다면 구분을 해주기 위해서
이름의 끝에 세미콜론을 써야 한다: ":Authors: Doe, Jane;".

"Address" 필드는 여러줄로 된 우편 주소를 위한 것이다.
개행과 공백 문자가 보존된다.

"Dedication"과 "Abstract" 필드는 임의의 본문 요소를 포함할 수 있다.
그러나 각각 하나씩만 포함할 수 있다. 본문 요소는
문서 정보 요소 바로 뒤에 "Dedication"이나 "Abstract" 제목을 가진 주제
요소가 된다.

이 field-name-to-element 맵핑은 다른 언어로 대체될 수 있다.
자세한 내용은 `DocInfo transform`_ 구현 문서를 참고하라.

지정되지 않았거나 일반적인(generic) 필드는 하나 이상의 단락이나 임의의
본문 요소를 포함할 수 있다. 필드 이름은 유요한 식별자 형식으로 변환된 후
"classes" 속성 값으로도 사용된다.


RCS Keywords
````````````

파서에 의해 인식된 `Bibliographic fields`_ 는 일반적으로 RCS [#]_ 키워드에
대해 확인되고 정리된다 [#]_.  RCS 키워드는 "$keyword$" 형식으로
소스 파일에 입력될 수 있고 일단 RCS나 CVS [#]_ 에 저장되면,
"$keyword: expansion text $"로 확장된다. 예를 들어, "Status" 필드는
"status" 요소로 변형될 것이다::

    :Status: $keyword: expansion text $

.. [#] Revision Control System.
.. [#] RCS keyword 처리를 중지시킬 수 있다 (구현되지 않음).
.. [#] Concurrent Versions System.  CVS는 RCS와 같은 키워드를 사용한다.

처리된 "status" 요소의 텍스트는 단순히 "expansion text"가 된다.
달러 표시 기호와 주요 RCS keyword 이름은 제거된다.

RCS keyword 처리는 필드 리스트가 서지 컨텍스트에 있을 때만 시작된다.
(문서의 첫 번째 비 주석(comment) 구조, 제목이 있는 경우 제목 다음에 있는 첫 비 주석 구조).


Option Lists
------------

독트리 요소: option_list, option_list 항목, 옵션 그룹, 옵션,
옵션 스트링, 옵션 인수, 설명.

Option lists 커맨드라인 옵션, 설명, 프로그램 옵션 기록에 대한 리스트다.
예시::

    -a         전부 출력.
    -b         둘 다 출력 (이 설명 조금
               길다).
    -c arg     인수만 출력.
    --long     하루종일 출력.

    -p         이 옵션은 설명이 두 단락으로 이루어져있다.
               이 단락이 첫 번째다.

               이 단락이 두 번째다. 옵션 사이의 공백 행은 위처럼 생략되거나
               여기나 아래처럼 남아있을 수 있다.

    --very-long-option  VMS 스타일 옵션. 두 칸의 공백이 요구된다는
                        사실을 명심하라.

    --an-even-longer-option
               설명 부분은 다음줄부터 시작해도 된다.

    -2, --two  이 옵션은 두 변형(variants)이 있다.

    -f FILE, --file=FILE  이 두 옵션의 의미는 같다; 둘 다 인수를
                          받는다.

    /V         VMS/DOS 스타일 옵션.

reStructuredText에 의해 인식되는 옵션 종류는 여러가지가 존재한다:

- 짧은 POSIX 옵션은 대쉬 하나와 한 글자짜리 옵션으로 구성되어 있다.
- 긴 POSIX 옵션은 대쉬 두 개와 한 단어로 구성되어 있다; 몇몇 시스템은
  대쉬 하나를 사용한다.
- 구식 GNU 스타일 "플러스" 옵션은 플러스기호 하나와 한 글자 옵션으로
  구성되어 있다 ("플러스" 옵션은 사라졌으며, 사용이 권장되지 않는다).
- DOS/VMS 옵션은 슬래쉬 하나와 옵션 한 글자 또는 한 단어로 구성되어 있다.

POSIX 스타일과 DOS/VMS 스타일 옵션은 도스나 윈도우즈 소프트웨어에서
모두 사용 가능하다. 위 스타일과 다른 변형은 종종 혼합되어 사용된다.
위의 이름은 단순히 편의를 위해서 선택되었다.

짧고 긴 POSIX 옵션을 위한 구문은 Python's getopt.py_ 모듈에 의해 지원되는
구문을 기반으로 한다. 이 모듈은 `GNU libc getopt_long()`_ 함수와 유사한 옵션
파서를 구연하지만 일부 제한이 있다. reStructuredText 옵션 리스트는 모든 변형
옵션 시스템을 지원하지는 않는다.

긴 POSIX와 DOS/VMS 옵션 단어는 커맨드라인에서 사용될 때 운영 시스템이나
응용 프로그램에 의해 잘릴 수 있지만, reStructuredText 옵션 리스트는
특수 구문으로 표시하거나 지원하지 않는다. 적용이 가능하다면
생략(truncation)에 대한 문서에 의해 지원되는 완전한 옵션 단어를 제공해야 한다.

옵션 뒤에는 인수 placeholder가 올 수 있는데 설명 부분에서 역할과 구문에 대한
안내를 해주어야 한다. 옵션과 인수 placeholder 사이에 스페이스나 등호를
구분 기호로 사용할 수 있다. "-" 또는 "+"만 사용 가능한 짧은 옵션은 구분 기호
를 생략할 수 있다. 옵션 인수는 아래의 두 가지 형식중 하나를 차용해야 한다:

- 알파벳(``[a-zA-Z]``)으로 시작하고 문자, 숫자, 하이픈(``[a-zA-Z0-9_-]``)
  으로 구성되어야 한다.
- 화살괄호로 시작(``<``)해서  화살괄호로 끝나야(``>``) 한다; 괄호 내에서는
  화살괄호를 제외하고 어떤 문자를 써도 상관이 없다.

하나의 설명을 공유하는 여러 옵션 '동의어'가 나열될 될 수 있다.
그 경우 콤마와 스페이스로 구분돼야 한다.

옵션과 설명 부분은 최소한 두 칸의 스페이스로 떨어져 있어야 한다.
설명은 여러 본문 요소를 포함할 수 있다. 옵션 마커 다음 첫 줄이 설명 부분의
들여쓰기를 결정한다. 다른 종류의 리스트와 마찬가지로 option list의 첫 번쨰
항목의 앞과 마지막 항목의 뒤에 공백 행이 삽입되어야 하며 옵션 사이에서는
선택적으로 사용할 수 있다.

단순화된 신택스 다이어그램::

    +----------------------------+-------------+
    | 옵션   [" " 인수]      "  "  | 설명         |
    +-------+--------------------+             |
            | (본문 요소)+                       |
            +----------------------------------+


Literal Blocks
--------------

독트리 요소: literal_block.

두 개의 콜론("::")으로 구성된 단락은 다음에 오는 텍스트 블락을 literal block
으로 변형시킨다. literal block은 들여쓰여지거나 인용 되어야 한다.
literal block 안에서는 마크업 처리가 되지 않는다. 일반적으로 고정폭 글꼴로
렌더링 된 채 있는 그대로 유지된다::

    이것은 일반적인 단락이다. 들여쓰여진 literal block이 다음에 위치한다.

    ::

        for a in [5,4,3,2,1]:   # 보이는 것처럼 이것은 프로그램 코드다
            print a
        print "it's..."
        # literal block은 들여쓰기가 끝나기 전까지 계속 이어진다

    이 텍스트는 첫 번째 단락의 들여쓰기 수준으로 돌아왔고, literal block의
    밖에 있기 때문에 일반적인 단락으로 처리된다.

콜론 두 개만으로 구성된 단락은 출력에서 완전히 제거된다. 빈 단락이
남아 있지 않는다.

편의상 "::"는 단락의 끝에서 인식된다. 공백 문자 바로 앞에 쓰여지면 두 콜론은
출력에서 모두 제거된다 (이것은 "부분적으로 최소화된" 형식이다).
"::" 바로 앞에 텍스트가 오면, *하나의* 콜론만 출력에서 제거되고 하나의 콜론은
남아서 보이게 된다 (즉, "::"가 ":"로 대체된다; 이것은 "완전히 최소화된" 형식이다).

다시 말해서 아래의 형태는 모두 동일하다 (단락 다음에 오는 콜론에 주목하라):

1. 확장된 형태::

      단락:

      ::

          Literal block

2. 부분적으로 최소화된 형태::

      단락: ::

          Literal block

3. 완전히 최소화된 형태::

      단락::

          Literal block

literal block의 들여쓰기를 위해 필요한 최소한의 부분을 제외한 모든 공백
문자는 보존된다. literal block의 전후로 공백 행이 필요하지만 공백 행은
literal block의 일부로 포함되지는 않는다.


Indented Literal Blocks
```````````````````````

Indented literal blocks 주변 텍스트에 비해 들여쓰여져서 표기된다
(각 줄이 공백 문자로 시작해야 함). indented literal block의 각 라인에서
최소로 들여쓰기 부분은 제거 된다. literal block은 연결되어 있을 필요는 없다;
들여쓰기된 텍스트의 섹션 사이에 공백 행을 삽입할 수 있다. literal block은
들여쓰기가 끝나는 부분에서 종료 된다.

신택스 다이어그램::

    +------------------------------+
    | 단락                          |
    | ("::"로 끝남)                 |
    +------------------------------+
       +---------------------------+
       | indented literal block    |
       +---------------------------+


Quoted Literal Blocks
`````````````````````

Quoted literal blocks는 들여쓰기되지 않은 이어진 텍스블락이며 각 행은
출력가능하면서 숫자나 문자가 아닌 동일한 7-bit ASCII 문자 [#]_ 로 시작한다.
인용 문자는 처리된 문서에서 그대로 보존된다.

.. [#]
   아래는 사용 가능한 인용 문자들이다::

       ! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~

   위 문자들은 sections_ 의 제목을 꾸밀 때 사용 가능한 문자들과 같다.

대화형 하스켈 프로그래밍이나 이메일 인용이 필요할 때 사용 가능하다::

    John Doe wrote::

    >> Great idea!
    >
    > Why didn't I think of that?

    You just did!  ;-)

구문 다이어그램::

    +------------------------------+
    | 단락                          |
    | ("::"로 끝남)                 |
    +------------------------------+
    +------------------------------+
    | ">" 인용된 라인                 |
    | ">" 공백 행 없이 이어져야 함      |
    +------------------------------+


Line Blocks
-----------

독트리 요소: line_block, 행. (Docutils 0.3.5.부터 가능)

Line blocks은 행의 구조가 중요한 주소 블럭(address blocks), 운문(verse)
(시, 노래 가사), 간소한 리스트 등을 나타낼 때 유용하다. Line blocks은
수직 막대("|")로 시작하는 행들의 그룹이다. 각각의 수직 막대는 새로운 행을
나타내기 떄문에 개행도 유지된다. 첫 번째 들여쓰기 또한 내포된(nested)된 구조를
형성하기 때문에 중요하다. 인라인 마크업이 지원된다.
연속 행(Continuation lines)은 긴 행이 래핑된(wrapped) 부분이다;
수직 막대 대신에 스페이스로 시작한다. 연속 행은 반드시 들여쓰여져야 하지만
위쪽의 텍스트와 왼쪽으로 똑같이 정렬되어 있을 필요는 없다. line block은
공백 행으로 끝난다.

아래는 연속 행을 설명하는 예시다::

    | Lend us a couple of bob till Thursday.
    | I'm absolutely skint.
    | But I'm expecting a postal order and I can pay you back
      as soon as it comes.
    | Love, Ewan.

새로운 행의 들여쓰기로 표시된 line blocks의 내포된 구조를 보여주는
예시::

    Take it away, Eric the Orchestra Leader!

        | A one, two, a one two three four
        |
        | Half a bee, philosophically,
        |     must, *ipso facto*, half not be.
        | But half the bee has got to be,
        |     *vis a vis* its entity.  D'you see?
        |
        | But can a bee be said to be
        |     or not to be an entire bee,
        |         when half the bee is not a bee,
        |             due to some ancient injury?
        |
        | Singing...

신택스 다이어그램::

    +------+-----------------------+
    | "| " | 행                    |
    +------| 연속 행               |
           +-----------------------+


Block Quotes
------------

독트리 요소: block_quote, attribution.

literal block이나 다른 내용을 나타내는 마크업 없이 선행된 텍스트에 비해
들여쓰기 된 텍스트 블락은 block quote라고 한다. block quote 안에서eh 본문 요소와
인라인 마크업을 위한 모든 마크업은 계속 처리된다::

    이것은 block quote를 설명하는, 일반적인 단락이다.

        "It is my business to know things.  That is my trade."

        -- Sherlock Holmes

Block quote은 attribution으로 끝날 수 있다: block quote에 맞춰 왼쪽 정렬된
"--", "---", 또는 엠 대쉬(em-dash)로 시작하는 텍스트 블럭을 attrubution이라고
한다. 만약 attribution이 여러 행으로 구성되어 있다면, 두 번째와 이후의 행들은
모두 반드시 왼쪽 가장자리가 정렬되어 있어야 한다.

Attribution으로 종료하면 여러 block quotes를 연속적으로 나타낼 수 있다.

    들여쓰여지지 않은 단락.

        Block quote 1.

        -- Attribution 1

        Block quote 2.

`Empty comments`_ 는 block quote를 흡수해버리는 선행 구조를
명시적으로 제거하기 위해 사용될 수 있다::

    * 리스트 항목.

    ..

        Block quote 3.

Empty comments는 block quotes를 분리시키는 데에도 사용할 수 있다::

        Block quote 4.

    ..

        Block quote 5.

block quote 전후로 공백 행이 필요하지만 이 공백 행들은 block quote
일부로 처리되지는 않는다.

Syntax diagram::

    +------------------------------+
    | (현재 들여쓰기                  |
    | 레벨)                         |
    +------------------------------+
       +---------------------------+
       | block quote               |
       | (본문 요소)+                |
       |                           |
       | -- attribution 텍스트      |
       |    (선택적)                |
       +---------------------------+


Doctest Blocks
--------------

독트리 요소: doctest_block.

Doctest blocks 독스트링(docstring)으로 복사 붙여넣기 된 대화형 Python 세션이다.
예시를 통해 사용법을 설명하고 파이썬 표준 라이브러리에 있는 `doctest
module`_ 을 통해서 우아하고 강력한 테스트 환경을 제공한다

Doctest blocks는 파이썬 대화형 인터프리터의 메인 프롬프트인 ``">>> "`` 로
시작하는 텍스트 블럭이며, 공백 행으로 끝난다. Doctest blocks은 lteral block 신택스를
요구하지 않으면서 literal block의 특수 케이스로 처리된다. 둘 다 존재하면,
literal block 신택스가 doctest block 신택스보다 우선적으로 처리된다::

    이것은 일반적인 단락이다.

    >>> print 'this is a Doctest block'
    this is a Doctest block

    아래는 literal block이다::

        >>> 이것은 reStructuredText에 의해 doctest block으로 인식되지
        않는지만 doctest module에 의해 인식되기는 한다.

doctest blocks는 들여쓰기를 요구하지 않는다.


Tables
------

독트리 요소: table, tgroup, colspec, thead, tbody, row, entry.

ReStructuredText는 테이블 셀(cell)을 그리기 위한 두 가지 신택스를 제공한다:
`Grid Tables`_, `Simple Tables`_.

다른 본문 요소와 마찬가지로, 테이블의 전후에는 공백 행이 필요하다.
테이블의 왼쪽 가장자리는 선행하는 텍스트 블럭의 가장자리에 맞춰 정렬 되여야 한다;
들여쓰기 되어있을 경우 테이블은 blokc quote의 일부로 인식된다.

일단 분리되면, 각각의 테이블은 작은 문서로서 처리된다; 셀의 위쪽 및 아래쪽
경계는 공백 행의 기능을 한다. 각 셀은 0개 이상의 본문 요소를 포함하고 있다.
셀의 컨텐츠는 처리되기 전에 제거되는 양쪽의 여백을 포함할 수 있다.


Grid Tables
```````````

Grid tables 격자 모양의 "ASCII art"를 통해서 완전한 테이블 표현을
제공한다. Grid tables는 임의의 셀 컨텐츠 (본문 요소)와 행, 열 병합을 모두
허용한다. 그러나 grid tables은 간단한 데이터 세트를 제작하기에는 복잡하고
번거로울 수 있다. `Emacs table mode`_ 는 grid tables를 쉽게 편집할 수 있게
도와주는 Emacs 도구다. 제한이 있지만 간단한 표현은 `Simple Tables`_ 를
참고하라.

Grid tables "-", "=", "|", "+"로 만들어진 그리드로 표현된다.
하이픈("-")은 수평적으로 행을 나누기 위해 쓰인다. 등호("=")는
테이블 본문의 헤더 행을 테이블 본문과 분리시키기 위해 사용될 수 있다
(`Emacs table mode`_ 에 의해 지원되지는 않는다). 수직 막대("|")는 열을
나누기 위해 사용된다. 플러스 기호("+")는 수직선과 수평선의 교차점을 표시하기
위해 사용된다. 예시::

    +------------------------+------------+----------+----------+
    | 헤더 행, 1 열            | 헤더 2      | 헤더 3   | 헤더 4     |
    | (헤더 행은 선택적이다)     |            |         |           |
    +========================+============+==========+==========+
    | 본문 1 행, 1 열          | 2 열       | 3 열      | 4 열     |
    +------------------------+------------+----------+----------+
    | 본문 2 행               | 셀은 열끼리 병합될 수 있다.            |
    +------------------------+------------+---------------------+
    | 본문 3 행               | 셀은 행끼    | - 테이블 셀은         |
    +------------------------+ 리 병합될    | - 본문 요소를         |
    | 본문 4 행               | 수 있다.     | - 포함한다.          |
    +------------------------+------------+---------------------+

셀 텍스트와의 원치 않는 상호작용을 피하기 위해서 주의해야 해야 한다.
예를 들면 아래 테이블의 2 행은 2 열부터 4 열까지 병합되어 있다::

    +--------------+----------+-----------+-----------+
    | 1 행, 1 열    | 2 열      | 3 열      | 4 열      |
    +--------------+----------+-----------+-----------+
    | 2 행          |                                  |
    +--------------+----------+-----------+-----------+
    | 3 행          |          |           |           |
    +--------------+----------+-----------+-----------+

만약 수직 막대가 셀 안에서 사용되면, 실수로 열의 경계와 정렬되었을 때
의도하지 않게 영향을 줄 수도 있다::

    +--------------+----------+-----------+-----------+
    | 1 행, 1 열    | 2 열     | 3 열       | 4 열      |
    +--------------+----------+-----------+-----------+
    | 2 행         | Use the command ``ls | more``.   |
    +--------------+----------+-----------+-----------+
    | 3 행         |          |           |           |
    +--------------+----------+-----------+-----------+

여러 가지 해결책이 존재한다. 어떤 해결책이 되었든 셀의 정사각형
경계의 연속성을 끊어버리면 된다. 한 가지 가능한 방법은 수직 막대 앞에
스페이스를 추가해 텍스트를 이동시켜버리는 것이다::

    +--------------+----------+-----------+-----------+
    | 1 행, 1 열    | 2 열     | 3 열       | 4 열      |
    +--------------+----------+-----------+-----------+
    | 2 행         |  Use the command ``ls  | more``.  |
    +--------------+----------+-----------+-----------+
    | 3 행         |          |           |           |
    +--------------+----------+-----------+-----------+

다른 방법은 2 행에 한 줄을 추가하는 것이다::

    +--------------+----------+-----------+-----------+
    | 1 행, 1 열    | 2 열     | 3 열       | 4 열      |
    +--------------+----------+-----------+-----------+
    | 2 행         | Use the command ``ls | more``.   |
    |              |                                  |
    +--------------+----------+-----------+-----------+
    | 3 행         |          |           |           |
    +--------------+----------+-----------+-----------+


Simple Tables
`````````````

Simple tables은 쉽고 간단하다. 하지만 단순한 데이터 셋의 제한적인 행 기반 테이블
표현만을 제공한다. 대부분의 셀에서 임의의 본문 요소가 표현될 수는 있지만
셀의 내용은 일반적으로 한 단락이다. Simple tables은 다중 행(첫 번째 열 제외)과
열 병합이 가능하지만 행 병합은 불가능하다. 완전한 테이블 표현에 대해서는 위쪽의
`Grid Tables`_ 를 참고하라.

Simple tables는 "="과 "-"로 만들어진 수평적인 경계로 표현된다.
등호("=")는 테이블의 위 아래 부분에 사용되고 테이블 본문과 테이블 헤더를
구분하기 위해 사용될 수도 있다. 하이픈("-")은 결합시킬 열에 밑줄을 표시해서
열의 병합을 나타내는 데 사용되고 명시적으로 행을 나누기 위해 선택적으로 사용
될 수도 있다.

Simple table은 상단에 등호와 열 경계를 구분하기 위한 하나 이상의
스페이스로 시작된다 (두 개 이상의 스페이스를 추천한다). 너비와 상관없이
위쪽 경계는 *반드시* 테이블의 모든 열을 표시해야 한다. 테이블에는
섹션 헤더와 구별하기 위해 최소 두 개 이상의 열이 있어야 한다. 위쪽 경계
다음에는 헤더 행이 올 것이고, 마지막 헤더 행의 아래에는 스페이스로 열이
구분된 '='로 이루어진 언더라인이 있다.
테이블의 하단 경계로 해석될 수 있기 때문에 헤더 행 구분 기호 아레에
공백 행은 없어야 한다. 테이블의 하단 경계는 '=' 밑줄과 열을 구분하는
스페이스로 구성된다. 예를 들어 아래의 (진리 표)truth table는 열 3개와
하나의 헤더 행, 본문 행 4개로 이루어져 있다::

    =====  =====  =======
      A      B    A and B
    =====  =====  =======
    False  False  False
    True   False  False
    False  True   False
    True   True   True
    =====  =====  =======

'-' 언더라인은 인접한 열을 합치기 위해 열의 경계를 "채우는" 방식으로 열의 병합을
나타내는 데 사용할 수 있다. 열 병합 언더라인은은 모든 열에 대하여 표시 되어야 하며
정해진 열의 경계에 맞춰서 정렬되어야 한다. 열 병합 언더라인을 포함하는 텍스트 줄은
다른 텍스트를 포함하면 안 된다. 열 병합 언더라인은 바로 위의 한 행에만 적용 된다.
아래는 헤더가 열 병합된 예시다::

    =====  =====  ======
       Inputs     Output
    ------------  ------
      A      B    A or B
    =====  =====  ======
    False  False  False
    True   False  True
    False  True   True
    True   True   True
    =====  =====  ======

각 텍스트 행은 열 병합이 되었을 경우를 제외하고는 열의 경계를 스페이스로
표시해야 한다. 첫 번째 열의 셀이 비어있을 때를 제외하고 각 텍스트 줄은 새로운
행으로 시작한다. 비어있을 경우 텍스트의 줄은 연속 행으로 파싱 된다.
이러한 이유로 인해서 (연속 행이 *아닌*) 새 행의 첫 번째 열에 있는 셀은
*반드시* 텍스트를 포함해야 한다; 빈 셀은 해석에 문제를 일으킬 수 있다
(아래의 팁을 참고하라). 또한 이 메커니즘은 첫 번째 열의 셀을 한 줄의 텍스트로
제한한다. 이러한 제한을 피하려면 `grid tables`_ 을 사용하라.

.. Tip::

   처리된 출력물에서 첫 번째 컬럼의 텍스트 없이 새 행을 시작하고 싶다면
   아래의 방법 중 하나를 사용하라:

   * empty comment ("..")는 처리된 출력에서 생략된다
     (아래의 Comments_ 참고하라)

   * 백슬래쉬 이스케이프 ("``\``")된 스페이스를 사용하라 (위의 `Escaping
     Mechanism`_ 을 참고하라)

'-' 언더라인은 열 병합이 아닐 때도 사용할 수 있다. 이것은 특히 행이 여러 줄로
이루어진 긴 테이블에서 유용하다.

simple tables 내에서 공백 행은 사용 가능하다. 공백 행의 해석은
컨텍스트에 따라 다르다. 행 *사이에* 있는 공백 행은 무시된다.
여러 줄로 이루어진 행 *내부의* 공백 행은 셀 안에 있는 본문 요소나
단락을 나누어 준다.

가장 오른쪽 열은 경계가 없다; 텍스트는 테이블 경계로 표시되어진 테이블의
가장자리를 지나서 계속 이어질 수 있다. 그러나, 경계가 텍스트 전체를 포함할
수 있도록 충분히 길게 만드는 것을 추천한다.

아래의 예시는 연속행을 설명한다 (2행은 두 줄의 텍스트, 3행은 4줄의 텍스트로
이루어져 있다). 32 행열의 공백 행은 단락을 나누고, 텍스트는 테이블의 오른쪽
경계를 지나서 연장되어 있고, 4 행의 첫 번째 열은 처리 후 출력될 떄 비어있게
다::

    =====  =====
    1  열  2 열
    =====  =====
    1      1행2열.
    2      2행2열.
           두 번째 단락.
    3      - 3행2열.

           - 3행2열의 bullet
             list.
    \      4행 ; 1열은 비어있다.
    =====  =====


Explicit Markup Blocks
----------------------

explicit markup block은 텍스트 블럭이다:

- ".."와 공백 문자로 시작한다("explicit markup start"),
- 두 번째 줄부터는 첫 번째 줄보다 들여쓰기 되어야 한다,
- 들여쓰기 되지 않은 줄 앞에서 끝난다.

Explicit markup blocks은 ".."를 글머리 기호로 사용하는 bullet list
항목과 비슷하다. explicit markup 바로 다음에 오는 텍스트는 블럭 본문의
들여쓰기를 결정한다. 공통된 최대로 들여쓰기된 부분은 블럭 본문의 두 번째
줄부터 제거된다. 그러므로 첫 번째 구문이 한 라인에 있고 첫 번째 줄과
두 번째 줄의 들여쓰기가 달라야 한다면, 첫 번째 구문이 explicit markup과 같은
줄에서 시작하면 안된다.

Explicit markup blocks과 다른 요소 사이에는 공백 행이 삽입되어야 하며
명백한 explicit markup block 사이에는 선택적으로 사용할 수 있다.

Explicit markup 구문은, 각주, 인용, 하이퍼링크, 명령어, 대체 정의, 코멘트를
위해 사용된다.


Footnotes
`````````

참조: `Footnote References`_.

독트리 요소: footnote_, label_.

환경 설정:
`footnote_references <footnote_references setting_>`_.

.. _footnote: ../doctree.html#footnote
.. _label: ../doctree.html#label
.. _footnote_references setting:
   ../../user/config.html#footnote-references-html4css1-writer

각각의 각주는 explicit markup start(".. ")와, 대괄호, 각주 라벨,
대활호, 공백문자, 들여쓰기된 본문 요소 순으로 구성되어 있다.
각주 라벨로는 아래의 것들을 사용할 수 있다:

- 한 개 이상의 십진수,

- 단일 "#"  (`auto-numbered footnotes`_),

- 간단한 참조 이름이 뒤에 오는 "#" (`autonumber label`_ ),
  또는

- 단일 "*" (`auto-symbol footnotes`_ 참고).

각주 내용 (본문 요소)는 최소한 스페이스 3개 이상으로 들여쓰여져야 한다.
각주에 있는 첫 번째 본문 요소는 각주 라벨과 같은 줄에서 시작할 수 있다.
그러나 첫 번째 요소가 같은 줄에 있고 남아있는 요소의 들여쓰기가 다르다면
첫 번째 요소는 반드시 각주 라벨 다음 줄부터 시작해야 한다. 그렇지 않으면
들여쓰기의 차이가 인식되지 않을 것이다.


각주는 문서의 끝 뿐만 아니라 어디에서나 삽입될 수 있다. 출력물에서 어디에
어떻게 나타날지는 처리 시스템에 따라 다르다.

아래는 직접 번호를 매긴 각주의 예시이다::

    .. [1] 본문 요소는 이곳에 위치한다.

각각의 각주는 자동적으로 자기 자신을 가리키는 하이퍼링크 타겟을 생성한다.
하이퍼링크 타겟 이름은 각주 라벨과 같다. `Auto-numbered footnotes`_ 는
각주 라벨과 참조 이름으로 번호를 생성한다. 메커니즘에 대한 자세한 설명은
`Implicit Hyperlink Targets`_ 를 참고하라.

신택스 다이어그램::

    +-------+-------------------------+
    | ".. " | "[" 라벨 "]" 각주        |
    +-------+                         |
            | (본문 요소)+             |
            +-------------------------+


Auto-Numbered Footnotes
.......................

번호 기호("#")는 각주와 각주 참조의 자동적 넘버링을 요청하는 각주 라벨의
첫 번재 문자로 사용될 수 있다.

수동으로 넘버링을 한 각주가 존재하지 않을 경우 자동 넘버링을 요청하는 첫 번째
각주는 라벨 "1"을 할당 받고 두 번재는 라벨 "2", 나머지도 순서대로 라벨을 할당
받는다 (아래 `Mixed Manual and Auto-Numbered Footnotes`_ 참고).
자동으로 라벨 "1"을 받은 각주는 라벨이 외부적으로(explicitly) 지정되는
것 처럼 "1"인 내부(implicit) 하이퍼링크 타겟을 생성한다.


.. _autonumber label: `autonumber labels`_

각주는 자동 넘버링 ``[#label]`` 을 요청하는 동시에 외부적으로 라벨을
지정할 수 있다. 이 라벨은 _`autonumber labels` 이라고 불린다.
Autonumber labels는 두 가지 일을 한다:

- 각주 자신에 대해서 이름이 autonumber label인 ("#"를 포함하지 않음) 하이퍼 링크
  타겟을 생성한다.

- 또한 각주 참조나 하이퍼링크 참조로서, 자동 넘버링 된 각주가
  여러번 참조되는 것을 허용한다::

      만약 [#note]_ 가 첫 번째 각주 참조라면, "[1]"로 나타날 것이다.
      우리는 이것을 다시 [#note]_ 로 참조할 수 있고 "[1]"로 보일 것이다.
      또한 우리는 note_ 로 참조할 수 있다 (일반 내부 하이퍼링크 참조).

      .. [#note] 이 것은 "note"로 레이블된 각주이다.

넘버링은 참조의 순서가 아니라 각주의 순서에 따라 결졍된다. 자동 숫자 라벨
(``[#]_``) 각주 참조의 경우, 각주와 각주 참조가 같은 순서로 되어 있어야
하지만 정확히(in lock-step) 번갈아(alternate) 나올 필요는 없다::

    [#]_ 는 각주 1에 대한 참조 번호, [#]_ 는 각주 2에 대한 참조 번호다.

    .. [#] 이건 각주 1.
    .. [#] 각주 2.
    .. [#] 각주 3 이다.

    [#]_ 는 각주 3에 대한 참조 번호다.

각주가 자동 넘버링 된 각주 참조 번호이거나 여러 참조 번호가 굉장히 근접해 있을
경우 특별한 주의가 필요하다. 각주와 참조 번호는 문서에서 등장하는 순서에 따라
기록되며 사람이 읽어야 하는 순서와 같을 필요는 없다.


Auto-Symbol Footnotes
.....................

별표("*")는 각주와 각주 참조를 위한 자동 심벌(symbol)을 생성을 요청하는 각주 라벨로
사용될 수 있다. 라벨에 다른 문자 없이 별표만 쓸 수도 있다::

    다음은 심벌 각주 참조: [*]_.

    .. [*] 이것이 각주다.

심벌은 대응하는 각주와 각주 참조에 라벨로 삽입될 것이다. 참조의 번호는
각주의 번호와 같다. 심벌 각주는 여러 참조를 가질 수 없다.

기본 Docutils 시스템은 각주 표시를 위해 아래의 심벌을 제공한다 [#]_:

- asterisk/star ("*")
- dagger (HTML character entity "&dagger;", Unicode U+02020)
- double dagger ("&Dagger;"/U+02021)
- section mark ("&sect;"/U+000A7)
- pilcrow or paragraph mark ("&para;"/U+000B6)
- number sign ("#")
- spade suit ("&spades;"/U+02660)
- heart suit ("&hearts;"/U+02665)
- diamond suit ("&diams;"/U+02666)
- club suit ("&clubs;"/U+02663)

.. [#] 이것은 The Chicago Manual of Style, 14th edition, section 12.51의
   "Note Reference Marks"에 있는 기호 리스트에서 영감을 받은 리스트다.
   CMoS에서는 pilcorw 대신에 "Parallels" ("||")이 제공되었다.
   마지막 4개의 기호(카드 무늬)는 임의로 추가 되었다.

10 개 이상의 기호가 필요하다면 동일한 순서로, 예를 들어 기호를 두 배("**"), 세 배 해서
재사용할 수 있다.

.. Note:: auto-symbol footnotes를 사용할 때, 출력 인코딩 방식을 선택하는 것은
   중요하다. 많은 기호가 Latin-1 (ISO 8859-1) 같은 특정한 특정한 인코딩 방식에서
   제대로 지원되지 않는다. 출력 인코딩 방식을 위해 UTF-8을 사용하는 것을 추천한다.
   HTML과 XML 출력을 위한 대안으로는 "xmlcharrefreplace"을 사용하라.
   `output encoding error handler`__ 참고.

__ ../../user/config.html#output-encoding-error-handler


Mixed Manual and Auto-Numbered Footnotes
........................................

결과를 제대로 예측할 수는 없지만 수동 및 자동 각주 넘버링은 한 문서에서
동시에 사용될 수 있다. 수동 넘버링이 우선순위가 높다. 사용되지 않은
각주 번호만이 자동 넘버링 각주에 할당된다. 아래의 예시를 확인하라::

    [2]_ 는 수동으로 넘버링된 "2"가 되고,
    [#]_ 는 자동으로 넘버링 된 "3"이 되고,
    [#label]_ 는 라벨이 자동으로 넘버링 된 "1"이 된다.

    .. [2] 이 각주는 수동으로 넘버링 되었기 때문에 숫자가 고정된다.

    .. [#label] 이 자동으로 숫자 라벨링 된 각주는 "1"로 라벨링 된다.
       이것은 처음으로 자동 넘버링된 각주고 라벨 "1"인 다른 각주는 존재하지
       않는다. 각주 참조의 순서가 아니라 각주의 순서가 넘버링을 결정한다.

    .. [#] 이 각주는 "3"으로 라벨링 될 것이다. 이 각주는 두 번째로
       자동 넘버링 된 각주지만 라벨 "2"는 이미 사용되었다.


Citations
`````````

참고: `Citation References`_.

독트리 요소: citation_

.. _citation: ../doctree.html#citation

인용은 ``[note]`` 나 ``[GVR2001]`` 같이 숫자가 아닌 라벨만 사용한다는 점을
제외하고는 각주와 동일하다. 인용 라벨은 단순한 `reference names`_ 이다
(공백 없이 대소문자를 구분하지 않은 문자, 숫자, 하이픈, 언더스코어, 구두점으로
이루어져있다. 인용은 각주와 달리 따로 렌더링 된다::

    이것은 인용 참조다: [CIT2002]_.

    .. [CIT2002] 이것은 인용이고 라벨이 문자인 것을 제외하면 각주와
       같다.


.. _hyperlinks:

Hyperlink Targets
`````````````````

독트리 요소: target_.

.. _target: ../doctree.html#target

이것은 아래에 정의된 `implicit hyperlink targets`_ 과 구별하기 위해
_`explicit hyperlink targets` 라고도 불린다.

하이퍼링크 타겟(hyperlink targets)은 `hyperlink references`_ 에 의해
연결된 문서의 외부 혹은 내부의 위치를 식별한다.

하이퍼링크 타겟은 이름이 있거나 익명으로 처리될 수 있다.
이름이 있는 하이퍼링크 타겟은 explicit markup start (".. ") 로 시작되고
언더스코어, 참조 이름, 콜론, 공백, 링크 블럭으로 이어진다::

    .. _하이퍼링크-이름: 링크-블럭

참조 이름은 대소문자를 구분하지 않고 공백 문자가 무효화 된다. 자세한 사항과
예시는 `Reference Names`_ 를 참고하라.

익명 하이퍼링크 타겟은 explicit markup start (".. ")와 언더스코어 두 개,
콜론, 콩백, 링크 블럭으로 이루어져 있으며 참조 이름은 없다::

    .. __: 익명-하이퍼링크-타겟-링크-블럭

익명 하이퍼링크의 대체 구문은 언더스코어 두 개, 스페이스, 링크 블럭으로
이루어져있다::

    __ 익명-하이퍼링크-타겟-링크-블럭

아래의 `Anonymous Hyperlinks`_ 참고하라.

하이퍼링크 타겟은 세 종류가 있다: 내부, 외부, 우회.

1. _`Internal hyperlink targets` 는 빈 링크 블럭을 가지고 있다. 이 타겟은
   하이퍼링크를 한 지점에서 문서 내의 다른 지점으로 연결해주는 목적지를 제공한다.
   내부 하이퍼링크 타겟은 타겟을 따르는 요소를 가리킨다. [#]_ 예시::

       이 내부 하이퍼링크를 클릭하면 아래에 있는 target_ 으로 데려다 준다.

       .. _target:

       위에 있는 하이퍼 링크 타겟은 이 단락을 가리킨다.

   내부 하이퍼링크 타겟은 "연결(chiained)"될 수 있다. 다수의 인접한
   내부 하이퍼링크 타겟은 같은 요소를 가리킨다::

       .. _target1:
       .. _target2:

       타겟 "target1"과 "target2"는 같다; 두 타겟은 모두 이
       단락을 가리킨다.

   가리켜지는 요소가 링크 블럭이 URI로 된 (아래의 #2를 참고)
   외부 하이퍼링크 타겟이라면 외부 하이퍼링크 타겟의
   URI는 내부 하이퍼링크 타겟으로 전파된다; 전부 같은 URI를
   가리키게 된다. URI를 복사할 필요가 없다. 예를 들어, 아래의 3개의
   하이퍼링크 타겟은 같은 URI를 참조한다::

       .. _Python DOC-SIG 메일 리스트 아카이브:
       .. _archive:
       .. _Doc-SIG: http://mail.python.org/pipermail/doc-sig/

   인라인 형태의 내부 하이퍼링크 타겟도 사용할 수 있다;
   `Inline Internal Targets`_ 를 참고하라.

   .. [#] 내부 하이퍼링크 타겟이 들여쓰기 된 텍스트 블럭의 끝에
      내포되어 있어도 사용할 수 있다. 이 작업을 통해서 타겟을 개별 리스트
      항목으로 설정할 수 있다 (선행하는 내부 대상이 리스트 전체에 적용되기 때문에
      첫 번째는 제외)::

       * bullet list

         .. _`두 번째 항목`:

       * 하이퍼링크 타겟이 있는 두 번째 항목.


2. _`External hyperlink targets` 는 링크 블럭이 절대 또는 상대 URI나
   이메일 주소다. 예를 들면, 아래처럼 입력을 받는다::

       See the Python_ home page for info.

       `Write to me`_ with your questions.

       .. _Python: http://www.python.org
       .. _Write to me: jdoe@example.com

   HTML로 처리된 이후, 하이퍼링크는 아래처럼 표시된다::

       See the <a href="http://www.python.org">Python</a> home page
       for info.

       <a href="mailto:jdoe@example.com">Write to me</a> with your
       questions.

   외부 하이퍼링크의 URI는 explicit markup start 와 타겟 이름이
   있는 같은 줄 또는 공백 행 없이 바로 다음에 들여쓰기 된 블럭으로 시작할
   수 있다. 링크 블럭이 여러 줄일 경우 블럭 내에서는 서로 이어진다.
   이스케이프 되지 않은 공백문자는 제거된다 (줄을 바꾸기 위한 공백만 허용이
   된다). 아래의 외부 하이퍼링크 타겟은 모두 동일하다::

       .. _one-liner: http://docutils.sourceforge.net/rst.html

       .. _starts-on-this-line: http://
          docutils.sourceforge.net/rst.html

       .. _entirely-below:
          http://docutils.
          sourceforge.net/rst.html

   이스케이프 된 공백 문자는, 의도적인 스페이스로 보존된다::

       .. _reference: ../local\ path\ with\ spaces.html

   외부 하이퍼링크 타겟의 URI가 마지막 문자로 언더스코어를 취하면
   우회 하이퍼링크 타겟으로 잘못 처리될 가능성이 있기 때문에 이스케이프
   되어야 한다::

       이 link_ 는 ``underscore_`` 라는 파일을 가리킨다.

       .. _link: underscore\_

   일반적으로 추천되지는 않지만 하이퍼링크 참조 안에서 URI를 직접 포함시키는
   것은 가능하다. 아래의 `Embedded URIs and Aliases`_ 를 참고하라.


3. _`Indirect hyperlink targets`\ 는 링크 블럭에 하이퍼링크 참조를 가지고 있다.
   아래의 예시에서 타겟 "one" 간접적으로 타겟 "two"가 참조하는 것을
   참조하고 타겟 "two"는 타겟 "three"가 참조하는 내부 하이퍼링크 타겟을
   참조한다. 결과적으로 세 개의 참조는 모두 같은 것을 가리킨다::

       .. _one: two_
       .. _two: three_
       .. _three:

   문서의 다른 곳에 있는 `hyperlink references`_ 처럼, 구문 참조
   (phrase-reference)가 링크 블럭에서 사용된다면 반드시 백 쿼트로 둘러싸여야 한다.
   `external hyperlink targets`_ 처럼, indirect hyperlink target의 링크
   블럭은 the explicit markup start가 있는 같은 줄이나 다음 줄에서 시작할
   수 있다. 링크 블록은 여러 줄로 분리될 수도 있으며 이 경우에는 정규화 되기 전에
   공백 문자로 연결된다.

   예를 들면, 아래의 indirect hyperlink targets은 모두 동일하다::

       .. _one-liner: `A HYPERLINK`_
       .. _entirely-below:
          `a    hyperlink`_
       .. _split: `A
          Hyperlink`_

   하이퍼링크 참조에 에일리어스(alias)를 직접 포함시키는 것도 가능하다.
   아래의 `Embedded URIs and Aliases`_ 를 참고하라.

그리고 참조 이름이 콜론을 포함하고 있다면:

- 구문은 반드시 백 쿼트로 싸여야 한다::

      .. _`FAQTS: Computers: Programming: Languages: Python`:
         http://python.faqts.com/

- 링크 타켓에서 백 슬래쉬로 이스케이프 되어야 한다::

      .. _Chapter One\: "Tadpole Days":

      It's not easy being green...

중복 참조 이름의 해결을 위해서는 아래의 `Implicit Hyperlink Targets`_ 을
참고하라.

신택스 다이어그램::

    +-------+----------------------+
    | ".. " | "_" 이름 ":" 링크     |
    +-------+ 블럭                 |
            |                      |
            +----------------------+


Anonymous Hyperlinks
....................

`World Wide Web Consortium`_ 는 `HTML Techniques for Web Content
Accessibility Guidelines`_ 에서 작성자가 각 링크에 대한 타켓을 명확하게 구분해놓을
것을 권장했다. 하이퍼링크 참조는 가능한 길어야 하지만 긴 하이퍼링크 이름을 타겟에
복제하는 것은 어렵고 에러를 일으키기 쉽다. 익명(Anonymous) 하이퍼링크는 장황한
하이퍼링크 참조를 편리하게 하도록 설계되었으며 `Auto-Numbered Footnotes`_
와 유사하다. 이것들은 특히 짧거나 하나로 구성된 문서에 유용하다. 그러나
이 장점은 쉽게 남용 되어서 텍스트를 읽을 수 없게 만들거나 문서를 보존할 수 없게
만든다. 사용할 때 주의할 필요가 있다.

익명 `hyperlink references`_ 는 하나가 아닌 두 언더스코어로 지정된다::

    `the web site of my favorite programming language`__.

익명 타겟은 ".. __:"로 시작하고; 참조 이름은 허용되지 않는다::

    .. __: http://www.python.org

더 쉽게 익명 타겟은 "__"만으로 시작할 수 있다::

    __ http://www.python.org

참조의 참조 이름은 참조와 참조 타겟의 이름과 매치되도록 사용되지 않는다.
대신에 문서에 있는 익명 하이퍼링크 참조의 순서와 타겟이 중요하다:
첫 번째 익명 참조는 첫 번째 익명 타겟과 연결된다. 문서의 익명 하이퍼링크 참조
갯수는 익명 타겟의 수와 같아야 된다. 가독성을 위해서 타겟이 참조와 가깝게 있도록
쓸 것을 추천한다. 익명 참조를 포함하는 텍스트를 편집할 때는 주의해야 한다:
참조를 재배열하거나 제거, 추가하는 경우에는 대응하는 타겟의 순서를 확인해야 한다.


Directives
``````````

Doctree elements: depend on the directive.

명령어(Directives)는 reStructuredText를 위한 확장 매커니즘으로
새로운 기본(primary) 신택스 추가 없이 새로운 구조에 대한 지원을 제공한다.
(명렁어는 지역적으로 추가적인 신택스를 지원할 수 있다). (reStructuredText
파서 레퍼런스에 등록되고 구현되어 있는) 모든 기본 명령어는 `reStructuredText
Directives`_ 문서에서 설명이 되어 있고, 언제든지 참고 가능하다.
명령어는 도메인에 따라 다르기 때문에, 문서를 처리할 때 사용하기 위해서는
특별한 조치가 필요할 수 있다.

예를 들어, 아래는 image_ 를 삽입할 수 있는 방식이다::

    .. image:: mylogo.jpeg

figure_ (캡션이 달린 그래프) 는 이런 식으로 삽입한다::

    .. figure:: larch.png

       The larch.

admonition_ (주석, 경고 등)은 다른 본문 요소를 포함한다::

    .. 주석:: 이것은 한 단락이다.

       - 여기에 bullet list가 위치한다.

명령어는 explicit markup start (".. ")와 명렁어 타입, 콜론 두 개
공백 문자로 표시되며 다 합쳐서 "명령어 마커"라고 부른다.
명령어 타입은 대소문자를 구분하지 않는 한 단어로 (공백 없이 문자, 숫자, 하이픈,
언더스코어 기호, 콜론, 마침표로 구성) 이루어져 있다. 명령어 타입 다음에는
아래와 같은 이유 때문에 콜론을 두 개 써준다.

- 일반적인 텍스트에서 쓰이는 것과 달리 콜론 두 개는 구분되기 쉽다.

- 콜론 두 개는 아래와 같은 일반적인 코맨트 텍스트와 충돌을 일으키지 않는다::

      .. Danger: modify at your own risk!

- reStructuredText를 실행했을 때 명령어를 인식하지 못하면 (directive-handler가
  설치되어 있지 않으면), level-3 (error) 시스템 메세지가 발생할 것이다.
  그리고 명령어를 포함한 전체 명령어 블럭이 literal block에 포함될 것이다.
  따라서 "::"가 당연히 선택된 것이다.

명령어 블럭은 명령어 마커 다음부터 시작되며 이후에는 들여쓰기된 텍스트
가 이어진다. 명령어 마커의 해석은 명령어 코드에 달려있다.
명령어 블럭에는 세가지 논리 파트가 있다:

1. 명령어 인수(Directive arguments).
2. 명령어 옵션(Directive options).
3. 명령어 내용(Directive contents).

각각의 명령어는 이 파트를 조합해서 사용할 수 있다. 명령어 인수는
파일 시스팀 경로(path), URL, 제목 텍스트 등이 올 수 있다. 명령어 옵션은
`field lists`_ 를 써서 표시된다; 필드 이름과 컨텐츠는 명령어에 한정되어 있다.
인수와 옵션은 명령어의 첫 번째나 두 번째 줄에서 시작하는 연속 블럭이
되어야 한다; 공백 행은 명령어 내용 블럭의 시작을 의미한다.
만약 인수나 옵션이 명령어에 의해 사용되면, 반드시 공백 행으로
명령어 내용과 분리시켜야 한다. "figure"는 세 파트를 모두 사용한다::

    .. figure:: larch.png
       :scale: 50

       The larch.

단순한 명령어는 내용이 필요하지 않다. 내용 블럭을 사용하지 않는
명령어 다음에 들여쓰기된 텍스트가 오게 되면 에러가 발생한다.
만약 명령어 바로 다음에 블럭 인용이 와야 하는 경우 사이에 빈 코멘트를
사용하라 (아래의 Comments_ 참고).

명령어로 인해 취해진 작동과 명령어 내용 블럭 또는
후속 텍스트 블럭에 있는 텍스트의 해석은 명령어에 의존한다.
자세한 내용은 `reStructuredText Directives`_ 를 참고하라.

명령어는 내용의 임의적인 처리를 위한 것이기 때문에 원본 텍스트와는 관련이 없는
것을 변형시킬 수도 있다. 명령어는 대체 신택스를 시험하는 것처럼
파서의 작동을 수정하기 위한 프라그마(pragma)로 사용될 수 있다.
현재는 이 기능을 위한 파서 지원은 없다; 프라그마 명령어를 위한 타당한 필요성이
발견되면 추후에 지원될 수도 있다.

명령어는 "명령어" 요소를 생성하지는 않는다; 이것은 단지
*파서 구조* 일 뿐이며 reStructuredText 외부에서는 본질적인 의미가 없다.
대신 파서는 인식된 명령어를 (특수한) 문서 요소로 변형한다. 알 수 없는
명령어는 level-3 (에러) 시스템 메세지를 발생시킨다.

신택스 다이어그램::

    +-------+-------------------------------+
    | ".. " | 명령어 타입 "::" 명령어           |
    +-------+ 블럭                           |
            |                               |
            +-------------------------------+


Substitution Definitions
````````````````````````

독트리 요소: 대체 정의(substitution_definition).

대체 정의는 explicit markup start (".. ")와, 수직 막대, 대체 텍스트,
수직 막대, 공백문자, 정의 블럭으로 구성되어 있다. 대체 텍스트는
공백 문자로 시작하고 끝날 필요는 없다. 대체 정의 블럭은 (앞에 ".." 없이)
"image_"나 "replace_" 같이 임베딩 된 인라인 호환 명령어를 포함할 수 있다::

    |biohazard| 기호는 의료 폐기물을 버리는 컨테이너에 쓰여야 한다.

    .. |biohazard| image:: biohazard.png

대체 정의 블럭이 직접적 혹은 간접적으로 순환 대체 참조를 포함하고 있을 경우
에러가 발생한다.

`Substitution references`_ 는 (대체 텍스트를 매칭해서 연결된) 대응되는 정의의
처리된 컨텐츠로 라인 안에서 대체된다. 매칭은 대소문자를 구별해서 이루어지지만
정확히 매치되는 것이 없는 경우 대소문자구분 없이 이루어진다.

대체 정의는 블럭 수준의 directives_ 가 인라인 텍스트로 공유되는 것을 허용한다.
세부적인 부분을 텍스트의 플로우(flow)로부터 영향을 받지 않게 하면서 텍스트에 있는 복잡한
인라인 구조를 임의로 포함시키는 방식으로 이루어진다. 그것들은 SGML/XML의 지정된
엔티티(entity)와 프로그래밍 언어 매크로(macro)와 같다.

대체 메커니즘 없이 특수한 용도의 인라인 구조를 원한다면 신택스 변경에 대해
청원해야(petition) 한다. 현재 사용되는 명령어 신택스와 결합한 인라인 구조는
(새로운 명령어를 제외하고) 새로운 신택스 없이 코딩될 수 있다.

신택스 다이어그램::

    +-------+-----------------------------------------------------+
    | ".. " | "|" 대체 텍스트 "| " 명령어 타입 "::" 데이터              |
    +-------+ 명령어 블럭                                           |
            |                                                     |
            +-----------------------------------------------------+

아래는 대체 메커니즘에 대한 사용 사례이다. 임베딩된 명령어의 대부분은
예시일 뿐 실제로 구현된 상태는 아니라는 사실을 명심하라.


객체
    대체 참조는 지정되지 않은 텍스트와 고유 객체 식별자(unique object identifier)
    를 결합킬 때 사용할 수 있다.

    예를 들어, 많은 사이트들은 인라인 "사용자" 명령어를 구현하기를 원한다::

        |Michael| and |Jon| are our widget-wranglers.

        .. |Michael| user:: mjones
        .. |Jon|     user:: jhl

    사이트의 필요에 따라, 이 것은 검색을 위해 문서를 인덱싱 하거나
    인라인 텍스트를 다양한 방식으로 (메일투(mailto), 홈페이지,
    프로파일과 연락처 정보가 있는 자바스크립트 마우스오버(mouseover) 등)
    하이퍼링크 하거나, 텍스트 표현을 커스터마이징 (유저 이름을 인라인 텍스트에
    포함시키거나, 링크가 있는 아이콘 이미지를 텍스트 다음에 포함시키거나,
    텍스트를 굵게 또는 다른 색으로 만드는 등) 할 때 사용될 수 있다.

    모호한 명칭이지만 고유 식별자가 있는 특정한 객체를 자주 참조하는
    문서에도 같은 접근 방식이 사용될 수 있다. 영화, 앨범, 책, 사진
    소송 사건, 법 등이 가능하다::

        |The Transparent Society| 개인정보 이슈에 대한 매력적인
        대안을 제시한다.

        .. |The Transparent Society| book:: isbn=0738201448

    문맥에서 모듈이나 클래스 이름이 명확하지 않고 해석된 텍스트가 사용될 수
    없는 클래스나 함수는 해석된 텍스트는 다른 가능성이 있다::

        4XSLT 는 편리한 |runString| 메서드를 가지고 있다, 따라서
        변형된 출력을 원하는 것 뿐이라면 DOM 객체를 사용할
        필요가 없다.

        .. |runString| function:: module=xml.xslt class=Processor

이미지
    대체 참조의 가장 일반적인 용도는 이미지다::

        West led the |H| 3, covered by dummy's |H| Q, East's |H| K,
        and trumped in hand with the |S| 2.

        .. |H| image:: /images/heart.png
           :height: 11
           :width: 11
        .. |S| image:: /images/spade.png
           :height: 11
           :width: 11

        * |Red light| means stop.
        * |Green light| means go.
        * |Yellow light| means go really fast.

        .. |Red light|    image:: red_light.png
        .. |Green light|  image:: green_light.png
        .. |Yellow light| image:: yellow_light.png

        |-><-| is the official symbol of POEE_.

        .. |-><-| image:: discord.png
        .. _POEE: http://www.poee.org/

    "image_" 명령어는 구현되어 있다.

스타일 [#]_
    대체 참조는 인라인 텍스트와 외부적으로 정의된 표현 스타일을
    결합시키기 위해 사용될 수 있다::

        심지어 |the text in Texas| 은 크다.

        .. |the text in Texas| style:: big

    스타일의 이름은 특정한 출력 형식의 컨텍스트에서는 유의미하지만 (HTML 출력을
    위한 CSS 클래스 이름, LaTeX 을 위한 LaTex 스타일 이름 등), 일반 텍스트 같은
    다른 출력 포멧에서는 무시될 수 있다.

    .. @@@ 이것은 다시 생각하고 작성하거나 제거되어야 한다:

       해석된 텍스트는 이 목적으로 적합하지는 않다. 왜냐하면 스타일 이름의
       집합이 미리 정의될 수 없기 때문이다. 이것은 파서나 출력 포맷터 제작자
       의 영역이 아니라 컨텐츠 작성자의 영역이다. 그리고 스타일 이름
       인수와 해석된 텍스트 스타일 기능을 결합시킬 방법은 없다.
       또한 스타일링 블럭에 같은 메커니즘을 사용하는 것이 더 바람직하다::

           .. style:: motto
              At Bob's Underwear Shop, we'll do anything to get in
              your pants.

           .. style:: disclaimer
              All rights reversed.  Reprint what you like.

    .. [#] 해석된 텍스트 기능 신택스의 확장 같은 더 간단한 신택스를 보장하는 스타일
       메커니즘에 대한 필요는 충분히 있다. 대체 메커니즘은 간단한 텍스트 스타일링에는
       복잡한 방식이다.

Templates
    인라인 마크업은 템플릿 엔진에 의해 추후에 처리되기 위해 사용될 수 있다.
    예를 들어 Zope_ 작성자는 이렇게 쓸 수 있다::

        Welcome back, |name|!

        .. |name| tal:: replace user/getUserName

    처리 후에, 이 ZPT 출력은 아래와 같이 나올 것이다::

        Welcome back,
        <span tal:replace="user/getUserName">name</span>!

    Zope는 다음에 세션에서 이것을 "Welcome back, David!"처럼 실제
    사용자로 변경할 것이다.

대체 텍스트
    대체 매커니즘은 간단한 매크로 대체을 위해서 사용될 수 있다.
    하나 이상의 문서에서 대체 텍스트가 반복될 때, 특히 나중에 바뀌어야
    될 필요가 있을 때 유용하다. 간단한 예시가 불가피하게 고안 되었다::

        |RST|_ 는 특히 |RST| 에 대해 쓸 때 계속 타이핑 하는 것을
        신경쓰이게 만든다. 그리고 매번 bicapitalized 단어를 설명하는
        것은 |RST| 소스 가독성을 위해서 꼭 필요하지 않다.

        .. |RST| replace:: reStructuredText
        .. _RST: http://docutils.sourceforge.net/rst.html

    대체 참조를 처음 사용할 때 언더스코어를 쓰는 것에 주의하라. 이것은
    대응하는 하이퍼링크 타겟에 대한 참조를 표시해준다.

    대체는 또한 대체 텍스트가 다른 인라인 구조를 사용해서 표현될 수 없을 때나
    지나치게 길 때 유용하다::

        하지만 |j2ee-cas|__ 같은 이름에 비하면 아무것도 아니다.

        .. |j2ee-cas| replace::
           the Java `TM`:super: 2 Platform, Enterprise Edition Client
           Access Services
        __ http://developer.java.sun.com/developer/earlyAccess/
           j2eecas/

    "replace_" 명령어는 구현되어 있다.


Comments
````````

독트리 요소: 코멘트(comment).

explicit markup start 뒤에 오는 임의의 들여쓰기된 텍스트는 코멘트 요소로
처리될 것이다. 코멘트 블럭의 텍스트에는 추가적인 처리가 이루어지지 않는다;
코멘트는 하나의 텍스트 블롭(blob)을 포함하고 있다. 출력 포맷터에
따라 코멘트는 처리된 결과물에서 제거될 수 있다. 코멘트에 대한 단 하나의 제한
사항은 코멘트는 다른 explicit markup 구조(대체 정의, 명령어, 각주, 인용,
하이퍼링크 타겟)와 같은 구문을 사용하지 않는다는 점이다. 다른 explicit markup
구조로 인식되지 않도록 하려면 ".."만 따로 한 행에 남겨두면 된다::

    .. This is a comment
    ..
       _so: is this!
    ..
       [and] this!
    ..
       this:: too!
    ..
       |even| this:: !

.. _empty comments:

explicit markup start 다음에 아무것도 없이(공백 문자 제외) 공백 행만 오면
"_`empty comment`"가 된다. 이것은 선행하는 구조를 종료하기 위해 사용되며
다음에 오는 들여쓰기된 텍스트를 흡수해버리지 않는다. 리스트나 다른 들여쓰기된
구조 다음에 block quote를 쓰기 위해서는 사이에 들여쓰기 되지 않은 empty comment를
삽입하라.

신택스 다이어그램::

    +-------+----------------------+
    | ".. " | 코멘트                |
    +-------+ 블럭                  |
            |                      |
            +----------------------+


Implicit Hyperlink Targets
==========================

암시적(Implicit) 하이퍼링크 타겟은 섹션 제목, 각주, 인용으로 생성되며
확장 구조에 의해서 생성될 수도 있다. 암시적 하이퍼링크 타겟은
명시적 `hyperlink targets`_ 과 동일하게 작동한다.

중복된 암시적(implicit), 명시적 참조 이름 충돌로 인한 모호성 문제는
아래의 절차에 의해 방지된다:

1. `Explicit hyperlink targets`_ 는 같은 참조 이름을 가진 암시적 타겟보다
   우선한다. 이때 암시적 하이퍼링크 타겟은 제거되고 level-1 (info) 시스템
   메세지가 삽입된다.

2. 중복된 암시적 하이퍼링크 타겟은 제거되고 level-1 (info)
   시스템 메세지가 삽입된다. 예를 들어, 엄격하게 구조화된(rigidly-structured)
   문서의 하위 "도입부" 섹션 같이 둘 이상의 섹션이 같은 제목을 가지고 있으면
   중복된 하이퍼링크 타겟이 생길 것이다.

3. 중복된 명시적 하이퍼링크 타겟은 제거되고 level-2 (warning) 시스템 메세지가
   삽입된다. 예외: (하이퍼링크 타겟과 참조 URI이 동일한) 중복된 `Explicit hyperlink targets`_
   은 충돌을 일으키지 않고 제거되지도 않는다.

시스템 메세지는 타겟 링크가 제거된 자리에 삽입된다. `PEP 258`_ 의
"에러 처리(Error Handling)" 부분을 참고하라 .

파서는 반드시 "고유한(unique)" 하이퍼 링크 세트를 반환해야 한다. Docutils_ 같은
호출 소프트웨어는 분석할 수 없는 링크에 대해서 경고 메세지와 원인을 출력한다.


Inline Markup
=============

reStructuredText에서 인라인 마크업은 텍스트 블럭 안에 있는 단어나 구에
적용된다. 텍스트에서 단어를 구분하기위해 사용되는 공백문자와 구두점은
인라인 마크업 신택스 구조를 구분하기 위해 똑같이 사용된다 (자세한 내용은
`inline markup recognition rules`_ 을 참고하라). 인라인 마크업 안에 있는
텍스트는 공백 문자로 시작하고 끝나지 않아도 된다. 권장되지는 않지만 임의의
`character-level inline markup`_ 이 지원된다. 인라인 마크업은 내포될
수 없다.

인라인 마크업 구조는 9개가 존재한다. 그중 다섯 개는 마크업을 표시하기 위해서
동일한 시작 스트링과 종료 스트링을 사용한다:

- emphasis_: "*"
- `strong emphasis`_: "**"
- `interpreted text`_: "`"
- `inline literals`_: "``"
- `substitution references`_: "|"

3개의 구조는 다른 시작 스트링과 끝 스트링을 사용한다:

- `inline internal targets`_: "_`" and "`"
- `footnote references`_: "[" and "]_"
- `hyperlink references`_: "`" and "\`_" (phrases), or just a
  trailing "_" (single words)

`Standalone hyperlinks`_ 는 내부적으로 인식되고, 추가적인 마크업을
사용하지 않는다.

Inline markup recognition rules
-------------------------------

인라인 마크업 시작 스트링과 끝 스트링은 아래의 조건이 충족되었을 때만
인식된다:

1. 인라인 마크업 시작 스트링 바로 다음에 공백 문자가 오지 않는다.

2. 인라인 마크업 종료 스트링 바로 앞에 공백 문자가 오지 않는다.

3. 인라인 마크업 시작 스트링과 종료 스트링 사이에는 최소한 한 문자가 포함되어야
   한다.

4. 인라인 마크업 시작 스트링과 종료 스트링 앞에는 `inline literals`_ 의 종료 스트링을
   제외하고 이스케이프 되지 않은 백슬래쉬가 오면 안 된다. 자세한 내용은
   `Escaping Mechanism`_ 을 참고하라.

5. 인라인 마크업 시작 스트링 바로 앞에 ASCII 문자 ``' " < ( [ {`` 나 유사한
   non-ASCII 문자 [#openers]_ 가 오고 바로 뒤에 ``' " ) ] } >`` 또는
   non-ASCII 문자 [#closers]_ 가 올 수 없다. 따옴표의 경우 `quotation
   marks in international usage`_ 에서 일치하는 문자일 수 있다.

`simple-inline-markup`_ 설정이 False로 되어 있으면 (디폴트), inline markup
주위에 오는 문자에 대해 추가적인 조건이 적용될 수 있다:

6. 인라인 마크업 시작 스트링은 텍스트 블럭을 시작하거나 아래의 문자 바로 뒤에
   있어야 한다.

   * 공백 문자,
   * ASCII 문자 중 하나 ``- : / ' " < ( [ {``
   * 유사한 non-ASCII 구분 문자. [#pre-chars]_

7. 인라인 마크업 종료 스트링은 텍스트 블럭을 종료시키거나 아래의 문자 바로 앞에
   있어야 한다.

   * 공백 문자,
   * ASCII 문자 중 하나 ``- . , : ; ! ? \ / ' " ) ] } >``
   * 유사한 non-ASCII 구분 문자. [#post-chars]_

.. [#openers]    `Unicode categories`_ `Ps` (Open), `Pi` (Initial quote),
                 or `Pf` (Final quote). [#uni-version]_
.. [#closers]    Unicode categories `Pe` (Close), `Pi` (Initial quote),
                 or `Pf` (Final quote). [#uni-version]_
.. [#pre-chars]  Unicode categories `Ps` (Open), `Pi` (Initial quote),
                 `Pf` (Final quote), `Pd` (Dash), or `Po` (Other). [#uni-version]_
.. [#post-chars] Unicode categories  `Pe` (Close), `Pi` (Initial quote),
                 `Pf` (Final quote), `Pd` (Dash), or `Po` (Other). [#uni-version]_

.. [#uni-version] 유니코드 표준의 발전에 따라 일부 문자의 카테고리가 변경되었다.
   Docutils 0.13은 `Unicode version 5.2.0`_ 를 사용한다.

.. _Unicode categories:
   http://www.unicode.org/Public/5.1.0/ucd/UCD.html#General_Category_Values
.. _Unicode version 5.2.0: http://www.unicode.org/Public/5.2.0/
.. _quotation marks in international usage:
   http://en.wikipedia.org/wiki/Quotation_mark,_non-English_usage

인라인 마크업 인식 규정은 이스케이핑 없는 마크업 용도가 아닌 "*", "`", "_", "|"의 사용의
90%가 가능하도록 고안되었다. 예를 들어 아래의 문장들은 인라인 마크업 스트링을 포함하지
않는 것으로 인식된다:

- 2 * x  a ** b  (* BOM32_* ` `` _ __ | (breaks rule 1)
- || (breaks rule 3)
- "*" '|' (*) [*] {*} <*>
  ‘*’ ‚*‘ ‘*‚ ’*’ ‚*’
  “*” „*“ “*„ ”*” „*”
  »*« ›*‹ «*» »*» ›*› (breaks rule 5)
- 2*x a**b O(N**2) e**(x*y) f(x)*f(y) a|b file*.*
  __init__ __init__()  (breaks rule 6)

아래의 인라인 마크업 예시에서 이스케이핑은 필요하지 않다:

- ``*2 * x  *a **b *.txt*`` (breaks rule 2; renders as "*2 * x  *a **b *.txt*")
- ``*2*x a**b O(N**2) e**(x*y) f(x)*f(y) a*(1+2)*``
  (breaks rule 7; renders as "*2*x a**b O(N**2) e**(x*y) f(x)*f(y) a*(1+2)*")

만약 코드 스니핏(snippets)을 표현하기 위해서라면 `inline literals`_ 를 사용하는 것을
권장한다. 이것은 작성자의 판단에 달렸다.

이 경우 해석이 잘못 되는 것을 막기 위해서 literal-quoting 이나 이스케이핑이 필요하다::

    \*4, class\_, \*args, \**kwargs, \`TeX-quoted', \*ML, \*.txt

대부분의 경우, `inline literals`_ 이나 `literal blocks`_ 을 사용하는 것이 가장
좋다. default 설정일 때, 한 번에 고정폭 글꼴로 변경된다::

    *4, class_, *args, **kwargs, `TeX-quoted', *ML, *.txt

단어 사이에 공백 문자를 사용하지 않는 언어의 경우(일본어, 중국어) `simple-inline-markup`_
을 True로 설정하고 인라인 마크업을 이스케이프하는 것을 추천한다. 위에 있는 규정 6과 7을
위반하는 예시는 어떤 구조가 특별한 주의를 요하는지 보여준다.


.. _simple-inline-markup: ../../user/config.html#simple-inline-markup


Recognition order
-----------------

인라인 마크업 구분자는 여러 구조에 의해서 사용된다 따라서 모호성을 피하기
위해서 각 문자에 대한 지정된 인식 순서가 있어야 한다. 인라인 마크업의 인식
순서는 다음과 같다:

- 별표: `Strong emphasis`_ ("**") 는 emphasis_ ("*") 전에 일어난다.

- 백 쿼트: `Inline literals`_ ("``")과 `inline internal targets`_
  (leading "_`", trailing "`")는 상호 독립적이며 `hyperlink references`_
  (leading "`", trailing "\`_") 와 `interpreted text`_ ("`") 구문 전에
  인식 된다.

- 뒤쪽 언더스코어: 각주 참조 ("[" + label + "]_") 와
  단순 `hyperlink references`_ (name + trailing "_")는 상호 독립적이다.

- 수직 막대: `Substitution references`_ ("|") are independently
  recognized.

- `Standalone hyperlinks`_ 는 가장 마지막에 인식된다.


Character-Level Inline Markup
-----------------------------

단어 사이의 개별 문자에 백슬래쉬 이스케이프로 마크업 할 수 있다.
(위쪽의 `Escaping Mechanism`_ 참고) 백슬래쉬 이스케이프는 임의의 텍스트를
인라인 마크업을 바로 뒤에 쓰도록 만드는 데 사용할 수 있다::

    Python ``list``\s use square bracket syntax.

백슬래쉬는 처리된 문서에서 사라질 것이다. 단어 "list"는 인라인 리터럴 텍스트로
나타날 것이고 문자 "s" 일반 텍스트로 스페이스 없이 바로 뒤에 써질 것이다.

임의의 텍스트는 백슬래쉬 이스케이프 된 공백문자를 사용하는 인라인 마크업 바로
앞에 위치한다::

    Possible in *re*\ ``Structured``\ *Text*, though not encouraged.

"re", "Structured", "Text"를 나누는 스페이스와 공백 문자는 처리된 문서에서
사라질 것이다.

.. CAUTION::

   문자 수준의 인라인 마크업을 위해 백슬래쉬 이스케이프를 사용하는 것은
   권장되지 않는다. 이러한 사용 방식은 처리되지 않은 문서의 가독성에 좋지 않은 영향을
   준다. 이 기능은 반드시 필요한 곳에만 사용하라.


Emphasis
--------

독트리 요소: 강조.

시작 스트링 = 종료 스트링 = "*".

별표 하나로 둘러싸인 단어는 강조된다::

    이것은 *강조된 텍스트* 다.

강조된 텍스트는 일반적으로 이탤릭체로 변한다.


Strong Emphasis
---------------

독트리 요소: strong.

시작 스트링 = 종료 스트링 = "**".

별표 두 개로 둘러싸인 텍스트는 강하게 강조된다::

    이것은 **강한 텍스트** 다.

강하게 강조된 텍스트는 일반적으로 굵게 변한다.


Interpreted Text
----------------

독트리 요소: 명시적 암시적 기능과 처리에 따라 달라짐.

시작 스트링 = 종료 스트링 = "`".

해석된 텍스트(Interpreted text)는 요약, 링크, 인덱싱 또는 다른 처리를 위한 텍스트이지만
일반적으로 그대로 남겨진 텍스트를 의미한다. Interpreted text는 백 쿼트
하나로 둘러싸여져있다::

    이것은 `interpreted text` 이다.

해석된 텍스트의 기능(role)은 텍스트가 해석될 방식을 결정한다.
기능은 내부적으로 (위처럼 "기본 기능"로 사용되는 것처럼) 유추되거나 기능 마커
를 이용해서 외부적으로 표시될 수도 있다. 기능 마커는 콜론과 기능 이름과 다른
콜론으로 이루어져있다. 기능 이름은 하이픈, 언더스코어, 플러스기호, 콜론, 구두점
등으로 구분된 영어와 숫자로 이루어진 한 단어다; 공백 문자나 다른 문자는 허용되지
않는다. 기능 마커는 해석된 텍스트의 앞에 혹은 뒤에 붙어도 상관 없다;
결정은 작성자의 몫이다::

    :role:`interpreted text`

    `interpreted text`:role:

해석된 텍스트는 사용 가능한 기술적(descriptive) 인라인 마크업 구조를 확장할 수 있다.
emphasis_, `strong emphasis`_, `inline literals`_, `hyperlink references`_ 에
"title reference", "index entry", "acronym", "class", "red", "blinking" 등
원하는 것을 추가할 수 있다. 사전에 지정되어 있는 role만 인식된다; 정해지지 않은 role은
에러를 발생시킨다. 표준 기능의 핵심 세트는 레퍼런스 파서에 구현되어 있다;
각각에 대한 설명은 `reStructuredText Interpreted Text Roles`_ 을 참고하라
role_ 명령어는 커스텀 해석된 텍스트 기능을 정하기 위해 사용할 수 있다.
또한 응용 프로그램은 특수 기능을 지원할 수 있다.


Inline Literals
---------------

독트리 요소: 리터럴(literal).

시작 스트링 = 종료 스트링 = "``".

더블 백쿼트로 싸인 텍스트는 인라인 리터럴(inline literal)로 취급된다::

    이 텍스트는 ``inline literals`` 예시다.

인라인 리터럴은 recognition rules에 따라 종료 스트링 컨텍스트에 두
백쿼트를 붙여서 쓰는 경우를 제외하고는 어떤 문자를 포함해도 된다.
인라인 리터럴 내에서는 백슬래쉬 이스케이프 해석을 포함해
마크업 해석이 전혀 이루어지지 않는다.

인라인 리터럴에서 개행은 불가능하다. reStructuredText 파서가
스페이스는 출력물에서 보존을 하지만 처리된 문서의 최종적인 모습은 출력 포맷터에
따라 다르다. 따라서 공백문자의 보존은 보장되지 않는다. 행 바꿈이나 다른 공백문자를
보존하는 것이 중요하다면 `literal blocks`_ 을 사용하라.

인라인 마크업은 짧은 코드를 표현할 때 유용하다::

    정규 표현식 ``[+-]?(\d+(\.\d*)?|\.\d+)`` 은은 지수가 없는
    부동소수점 숫자와 일치한다.


Hyperlink References
--------------------

독트리 요소: 참조.

- Named hyperlink references:

  - 시작 스트링 없음, 종료 스트링 = "_".
  - 시작 스트링 = "`", 종료 스트링 = "\`_".  (구문 참조.)

- Anonymous hyperlink references:

  - 시작 스트링 없음, 종료 스트링 = "__".
  - 시작 스트링 = "`", 종료 스트링 = "\`__".  (구문 참조.)

하이퍼링크 참조는 독립적으로 인식되는 `standalone hyperlinks`_ 를
제외하고는 뒤쪽 언더스코어, "_"에 의해 표시된다. 언더스코어는 오른쪽을
가리키는 화살표로 생각될 수 있다. 뒤쪽 언더스코어는 하이퍼링크 참조로부터
가키리는 것이고, 앞쪽 언더스코어는 `hyperlink targets`_ 를 가리키는 것이다.

하이퍼링크는 두 부분으로 구성되어 있다. 텍스트 본문에는 뒤쪽 언더스코어가 있는 참조 이름인
소스 링크(source link)가 있다. 또는 `anonymous hyperlinks`_ 를 위해 두
개의 언더스코어가 있을 수 있다::

    See the Python_ home page for info.

매치되는 참조 이름이 있는 타겟 링크는 문서 어딘가에는 존재해야 한다.
자세한 설명은 `Hyperlink Targets`_ 를 참고하라.

`Anonymous hyperlinks`_ 는 레퍼런스와 타겟을 매치시키기 위해 참조 이름을 쓰지
않는다. 하지만 그 외에는 named hyperlinks와 유사하게 작동한다.


Embedded URIs and Aliases
`````````````````````````

하이퍼링크 참조는 아래 처럼 타겟 URI나 (Docutils 0.11 이후) 하이퍼링크 참조를
화살 괄호 ("<...>") 안에 바로 집어넣을 수 있다::

    See the `Python home page <http://www.python.org>`_ for info.

    This `link <Python home page_>`_ is an alias to the link above.

이것은 아래와 정확히 똑같다::

    See the `Python home page`_ for info.

    This link_ is an alias to the link above.

    .. _Python home page: http://www.python.org
    .. _link: `Python home page`_

괄호에 싸인 URI 바로 앞에는 공백 문자가 와야 하고 종료 스트링 앞의 마지막 문자는
텍스트가 되어야 한다.

단일 뒤쪽 언더스코어가 있으면, 참조는 이름이 지정되고 같은 타겟 URI가
다시 참조된다. 뒤쪽 언더스코어가 두 개 있으면, 레퍼런스와 타겟은 모두 익명
처리 되고 타겟은 다시 참조되지 않는다. 이것은 "one-off" 하이퍼링크라고 한다::

    `RFC 2396 <http://www.rfc-editor.org/rfc/rfc2396.txt>`__ and `RFC
    2732 <http://www.rfc-editor.org/rfc/rfc2732.txt>`__ together
    define the syntax of URIs.

위의 예시는 아래와 같다::

    `RFC 2396`__ and `RFC 2732`__ together define the syntax of URIs.

    __ http://www.rfc-editor.org/rfc/rfc2396.txt
    __ http://www.rfc-editor.org/rfc/rfc2732.txt

`Standalone hyperlinks`_ 는 파이썬 함수 문서의 예시에 있는 것 처럼
언더스코어로 끝나도 URI로 취급된다::

    `__init__ <http:example.py.html#__init__>`__

`standalone hyperlink`_ 로 인식되지 않는 타겟 URI가 언더스코어로 끝나면
하이퍼링크 참조 파싱되는 것을 막기 위하여 백슬래쉬 이스케이프 되어야 한다::

    Use the `source <parrots.txt\_>`__.

위의 예시는 파일 ``parrots.txt_`` 에 대한 익명 참조를 만든다.

참조 텍스트가 화살괄호로 둘러싸인 URI나 하이퍼링크 참조가 아닌 텍스트로 끝나면
최소한 하나의 화살괄호는 백슬래쉬 이스케이프 되거나 이스케이프된 스페이스를 뒤에
써줘야 한다. 아래는 태그를 설명하는 제목에 대한 참조 세가지다.::

    See `HTML Element: \<a>`_, `HTML Element: <b\> `_, and
    `HTML Element: <c>\ `_.

참조 텍스트는 생략될 수 있다. 이 경우 URI는 참조 텍스트로 사용되기 위해 복제된다.
이것은 주소나 파일 이름이 바람직한 참조 텍스트인 상대 URI일 때 유용하다::

    See `<a_named_relative_link>`_ or `<an_anonymous_relative_link>`__
    for details.

.. CAUTION::

   이 구조는 일반적인 하이퍼링크의 유지나 작성을 쉽게 하지만 가독성을
   훼손시킨다. 특히 긴 인라인 URI의 경우 텍스트의 자연적인 흐름을 방해하기 쉽다.
   소스 형식으로 읽으려는 문서는 독립적인 블럭 레벨의 `hyperlink
   targets`_ 을 사용할 것을 **강력히 권장한다**. 임베딩된 URI 구조는 오로지
   처리된 형식으로 읽도록 된 문서에 가장 적합하다.


Inline Internal Targets
------------------------

독트리 요소: 타겟.

시작 스트링 = "_`", 종료 스트링 = "`".

인라인 인터널 타겟(Inline internal target)은 명시적 `internal
hyperlink targets`_ 링과 동일하지만 텍스트 안에서 나타난다. 신택스는
언더스코어와 백 쿼트로 시작한 다음 하이퍼링크 단어나 구가 오고 백쿼트로 끝난다.
인라인 인터널 타겟은 익명처리될 수 없다.

예를 들어 아래의 단락은 "Norwegian Blue"이라는 이름의 하이퍼링크 타겟을
포함하고 있다::

    Oh yes, the _`Norwegian Blue`.  What's, um, what's wrong with it?

중복된 참조 이름 해결 방법은 `Implicit Hyperlink Targets`_ 를 참고하라.


Footnote References
-------------------

참고: Footnotes_

독트리 요소: footnote_reference_.

환경 설정:
`footnote_references <footnote_references setting_>`_,
trim_footnote_reference_space_.

.. _footnote_reference: ../doctree.html#footnote-reference
.. _trim_footnote_reference_space:
   ../../user/config.html#trim-footnote-reference-space

시작 스트링 = "[", 종료 스트링 = "]_".

각각의 각주 참조(footnote reference)는 대괄호로 묶인 라벨과 끝 언더스코어로
구성되어 있다. 각주의 라벨은 아래 중 하나로 쓸 수 있다:

- 한 자리 이상의 숫자,

- 단일 "#" (`auto-numbered footnotes`_ 참조),

- 간단한 참조 이름이 뒤에 있는 "#" (an `autonumber label`_),
  or

- 단일 "*" (`auto-symbol footnotes`_ 참고).

예시::

    Please RTFM [1]_.

    .. [1] Read The Fine Manual

`Inline markup recognition rules`_ 은 각주 참조 앞에 공백을 요구한다.
출력물에서 공백을 제거하고 싶으면 이스케이프된 공백 문자를 사용하거나
(`Escaping Mechanism`_ 참고), trim_footnote_reference_space_ 환경 설정을
변경하라. `footnote_references setting`_ 이 "superscript"로 설정되어 있으면
앞에 있는 공백은 기본적으로 제거된다.


Citation References
-------------------

참고: Citations_

독트리 요소: citation_reference_.

.. _citation_reference: ../doctree.html#citation_reference

시작 스트링 = "[", 종료 스트링 = "]_".

각각의 인용 참조(citation reference)는 대괄호로 묶인 라벨과 끝 언더스코어로
구성되어 있다. 인용 라벨은  단순한 `reference names`_ 이며 대소문자 구별 없이
문자, 숫자, 내부 하이픈, 언더스코어, 마침표 등으로 이루어진 공백 없는 단일
단어이다.

예시::

    다음이 인용 참조다: [CIT2002]_.


Substitution References
-----------------------

독트리 요소: substitution_reference, reference.

시작 스트링 = "|", 종료 스트링 = "|" (추가적으로 "_"나 "__"가 뒤에 올 수 있음.)

수직 막대는 대체 참조(substitution reference) 텍스트를 감싸기 위해 사용 된다.
대체 참조는 "_"(지정)나 "__"(익명)를 덧붙여서 하이퍼링크 참조로 사용될 수도 있다;
대체 텍스트는 지정된 경우에 참조 텍스트로 사용된다.

처리 시스템은 대체 참조를 `substitution definitions`_ 에 대응하는 처리된 컨텐츠로
대체한다. 대체 정의는 인라인으로 호환가능한 요소를 생성한다.

예시::

    다음은 간단한 |substitution reference| 이다. 이것은 처리 시스템에 의해
    대체될 것이다.

    다음은 |substitution and hyperlink reference|_ 조합이다. 대체 텍스트와
    요소는 대체될 뿐 아니라 "substitution and hyperlink reference" 타겟을
    참조할 것이다.

.. _standalone hyperlink:

Standalone Hyperlinks
---------------------

Doctree element: reference.

시작 스트링이나 종료 스트링 없음.

텍스트 블럭에 있는 URI(절대 URI [#URI]_ 나 자립(standalone) 이메일 주소)는
URI 자체가 링크의 텍스트인 일반 외부 하이퍼링크로 처리된다.
예시::

    See http://www.python.org for info.

HTML에서는 아래처럼 마크업 된다as::

    See <a href="http://www.python.org">http://www.python.org</a> for
    info.

인식되는 형식의 URI는 두 가지다:

1. 절대 URI. 절대 URI는 스킴(scheme)과 콜론(":") 하나, 스킴에 따라
   해석되는 스킴 고유(scheme-specific) 부분으로 구성된다.

   스킴은 "http", "ftp", "malito", "telnet" 같은 프로토콜(protocol)의
   이름이다. 스킴은 첫 문자와 뒤 따르는 문자, 숫자, "+", "-", "."로
   구성된다. 인식은 `Official IANA Registry of URI Schemes`_ 와
   W3C의 `Retired Index of WWW Addressing Schemes`_ 에 의해 알려진
   스킴으로 제한 된다.

   리소스 식별자(resource indentifier)의 스킴 고유 부분은 계층적
   (hierarchical)이거나 opaque할 수 있다:

   - 계층적 식별자는 하나 또는 구 개의 슬래쉬로 시작하고 경로(path)의
     계층적 성분(component)를 분리하기 위해 슬래쉬를 사용한다.
     아래는 웹 페이지와 FTP 사이트의 예시다::

         http://www.python.org

         ftp://ftp.python.org/pub/python

   - Opaque 식별자는 슬래쉬로 시작하지 않는다. 아래는 이베일 주소와
     뉴스그룹 예시다::

         mailto:someone@somewhere.com

         news:comp.lang.python

   쿼리(queries), 프래그먼트(fragments), %-이스케이프 된 시퀀스(sequences)
   로 인해 URI는 복잡해질 수 있다. reStructuredText 파서는
   RFC2396_ 와 RFC2732_ 에 정의된 절대 URI는 모두 인식할 수 있다.

2. 자립형 이메일 주소는 "mailto:" 스킴이 있는 절대 URI로 처리된다.
   예시::

       someone@somewhere.com

URI가 화살괄호(">")로 끝나지 않으면 마지막에 에 있는 마침표는 URI의
일부로 인식되지 않는다. 백슬래쉬는 URI 문자로 유효한 별표나 언더스코어 같은
마크업 문자를 이스케이프 하기 위해서 URI 내에서 사용될 수 있다.
(위쪽의 `Escaping Mechanism`_ 참고).

.. [#URI] Uniform Resource Identifier.  URI는 URL(Uniform Resource
   Locators)의 일반 형식이다. URI 신택스는 RFC2396_ 와 RFC2732_ 를
   참고하라.


Units
=====

(New in Docutils 0.3.10.)

모든 측정값은 표준 (비과학) 표기법에 있는 양의 부동소수점 숫자와, 하나 이상의
공백으로 구분되어 있는 단위로 구성되어 있다.

단위는 레퍼런스 메뉴얼에 명시적으로 언급되었을 때만 지원된다.


Length Units
------------

아래의 길이 단위는 reStructuredText 파서에 의해 지원된다:

* em (ems, 글꼴의 높이)
* ex (x-height, 글자 "x"의 높이)
* px (pixels, 캔버스(canvas) 해상도와 관련)
* in (inches; 1in=2.54cm)
* cm (centimeters; 1cm=10mm)
* mm (millimeters)
* pt (points; 1pt=1/72in)
* pc (picas; 1pc=12pt)

이 세트는 `length units in CSS`_ 와 일치한다.

(리스트와 설명은 http://www.htmlhelp.com/reference/css/units.html#length
를 참고했다.)

다음은 모두 유효한 길이 단위이다: "1.5em", "20 mm", ".5in".

단위가 없는 길이 값은 writer 종속 기본 설정으로 작성된다 (예, `html4css1`의
px, `latex2e`의 pt). 자세한 내용은 `user doc`__ 에 있는 writer 지정
도큐먼테이션을 참고하라.

.. _length units in CSS:
   http://www.w3.org/TR/CSS2/syndata.html#length-units

__ ../../user/

Percentage Units
----------------

퍼센트 값은 단위로 퍼센트 기호("%")를 사용한다. 퍼센트 값은 값이
발생하는 컨텍스트에 따라 다른 값들에 비례한다.


----------------
 Error Handling
----------------

독트리 요소: system_message, problematic.

마크업 오류는 `PEP 258`_ 에 있는 설명에 따라 처리된다.


.. _reStructuredText: http://docutils.sourceforge.net/rst.html
.. _Docutils: http://docutils.sourceforge.net/
.. _The Docutils Document Tree: ../doctree.html
.. _Docutils Generic DTD: ../docutils.dtd
.. _transforms:
   http://docutils.sourceforge.net/docutils/transforms/
.. _Grouch: http://www.mems-exchange.org/software/grouch/
.. _RFC822: http://www.rfc-editor.org/rfc/rfc822.txt
.. _DocTitle transform:
.. _DocInfo transform:
   http://docutils.sourceforge.net/docutils/transforms/frontmatter.py
.. _getopt.py:
   http://www.python.org/doc/current/lib/module-getopt.html
.. _GNU libc getopt_long():
   http://www.gnu.org/software/libc/manual/html_node/Getopt-Long-Options.html
.. _doctest module:
   http://www.python.org/doc/current/lib/module-doctest.html
.. _Emacs table mode: http://table.sourceforge.net/
.. _Official IANA Registry of URI Schemes:
   http://www.iana.org/assignments/uri-schemes
.. _Retired Index of WWW Addressing Schemes:
   http://www.w3.org/Addressing/schemes.html
.. _World Wide Web Consortium: http://www.w3.org/
.. _HTML Techniques for Web Content Accessibility Guidelines:
   http://www.w3.org/TR/WCAG10-HTML-TECHS/#link-text
.. _image: directives.html#image
.. _replace: directives.html#replace
.. _meta: directives.html#meta
.. _figure: directives.html#figure
.. _admonition: directives.html#admonitions
.. _role: directives.html#custom-interpreted-text-roles
.. _reStructuredText Directives: directives.html
.. _reStructuredText Interpreted Text Roles: roles.html
.. _RFC2396: http://www.rfc-editor.org/rfc/rfc2396.txt
.. _RFC2732: http://www.rfc-editor.org/rfc/rfc2732.txt
.. _Zope: http://www.zope.com/
.. _PEP 258: ../../peps/pep-0258.html


..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   End:
